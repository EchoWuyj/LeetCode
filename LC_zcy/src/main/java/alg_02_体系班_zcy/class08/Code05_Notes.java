package alg_02_体系班_zcy.class08;

/**
 * @Author Wuyj
 * @DateTime 2022-09-22 14:58
 * @Version 1.0
 */
public class Code05_Notes {

    // 排序算法的稳定性
    // 稳定性是指同样大小的样本,再排序之后不会改变原来的相对次序

    // 排序前 [2,1,1,3,2,3]
    //        A a b i B ii
    // 排序后 [1,1,2,2,3,3]
    //        a b A B i ii
    // 排序时,相等元素的相对次序,没有发生改变则叫有稳定性,有稳定性即会保留相对次序

    // 对基础类型来说,稳定性毫无意义
    // 对非基础类型来说,稳定性有重要意义
    //    如:第一次按照学生成绩升序,再按照班级升序,有稳定性则会保留相对次序,班级内的学生成绩是升序的

    // 有些排序算法可以实现成稳定的
    //   冒泡排序(相等时不往后交换,保留相对次序)
    //   插入排序(相等时不往前交换,保留相对次序)
    //   归并排序(相等时,先copy左组值到help数组,再去copy右组值到help数组,保留相对次序)

    // 而有些排序算法无论如何都实现不成稳定的
    //   选择排序(存在最小值的交换,不能保证相对次序,故不稳定)
    //   快排排序(partition过程不稳定,故不稳定)
    //   堆排序(堆调过程直接破坏稳定性)

    //----------------------------------------------------

    //           时间复杂度  额外空间复杂度     稳定性
    // 选择排序    O(N^2)       O(1)            无
    // 冒泡排序    O(N^2)       O(1)            有
    // 插入排序    O(N^2)       0(1)            有
    // 归并排序    O(N*logN)    O(N)            有
    // 随机快排    O(N*logN)    O(logN)         无
    // 堆排序      O(N*logN)    0(1)            无
    // ===================================================
    // 计数排序    O(N)         O(M)            有
    // 基数排序    O(N)         O(N)            有

    // 排序算法总结
    // 1)不基于比较的排序,对样本数据有严格要求,不易改写
    // 2)基于比较的排序,只要规定好两个样本怎么比大小,就可以直接复用
    // 3)基于比较的排序,时间复杂度的极限是O(N*logN)
    // 4)时间复杂度O(N*logN),额外空间复杂度低于O(N),且稳定的,基于比较的排序是不存在的
    // 5)为了绝对的速度:选快排,为了省空间:选堆排,为了稳定性:选归并

    // 常见的坑(不用看)
    // 1)归并排序的额外空间复杂度可以变成O(1),"归并排序,内部缓存法",但是将变得不再稳定
    // 2)"原地归并排序"是垃圾贴,会让时间复杂度变成O(N^2)
    // 3)快速排序稳定性改进,"01 stable sort",但是会对样本数据要求更多

    // 常见的坑(不用看)
    // 在整型数组中,请把奇数放在数组左边,偶数放在数组右边
    // 要求所有奇数之间原始的相对次序不变,所有偶数之间原始相对次序不变
    // 时间复杂度做到O(N),额外空间复杂度做到O(1) -> 很难实现

    // 工程上对排序的改进
    // 1)稳定性的考虑
    //  Arrays.sort()方法
    //  a.如果排序的array是基础类型,sort里面使用改进后的快排
    //    因为基础类型不需要稳定性,所以使用相对来说比较快的快排
    //  b.如果排序的array是非基础型,sort里面使用归并排序,
    //    不知道是否需要稳定性,但是系统需要保证是稳定的,所以使用归并
    // 2)充分利用O(N*logN)和O(N^2)排序各自的优势
    //   插入排序 O(N^2) 常数项小(系数)
    //   快排 O(N*logN) 常数项大(系数)
    //   N在数据量很大时,使用快排,能充分体现整体的调度性能的优秀
    //   N在数据量不大时,有限几个数,常数项优势明显,插入排序实际运行的时间是快于快排的
}
