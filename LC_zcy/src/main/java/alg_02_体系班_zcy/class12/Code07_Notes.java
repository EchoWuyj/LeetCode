package alg_02_体系班_zcy.class12;

/**
 * @Author Wuyj
 * @DateTime 2022-09-28 0:07
 * @Version 1.0
 */
public class Code07_Notes {

    // 以上的每个问题,时间复杂度都是O(N)
    // N是节点个数,看上去比较麻烦,但是其实都是最优解

    //     root
    // 左树    右树
    // 1)先通过左树要点信息回来
    // 2)再通过右树要点信息回来
    // 3)最后回到root节点,对左右数的信息进行整合
    // =>本质:二叉树的后序遍历,所有关键操作都是在两个递归函数之后进行的
    // =>在树上做动态规划,树型DP

    // 1)思想提醒
    //   a.不管遇到什么题,都想X为头的目标怎么实现?
    //   b.手段:通过左树要信息,右树要信息,思考这个目标怎么实现?
    //   c.列可能性是最重要的,常见分类,和X有关,和X无关时
    //     向左右树要来简单信息(常数时间能得到)
    // 2)模板化
    //   a.info,process..
    //   b.关键如何加工得到info信息,这点是需要自己实现的

    // 二叉树的递归套路(PPT)(大的套路之一)
    // 1)假设以X节点为头,假设可以向X左树和X右树要任何信息
    // 2)在上一步的假设下,讨论以X为头节点的树,得到答案的可能性(最重要)
    // 3)列出所有可能性后,确定到底需要向左树和右树要什么样的信息
    // 4)把左树信息和右树信息求全集,就是任何一棵子树都需要返回的信息S
    // 5)递归函数都返回S,每一棵子树都这么要求
    // 6)写代码,在代码中考虑如何把左树的信息和右树信息整合出整棵树的信息

    // 精简
    // (1)分析问题的各种可能性
    // (2)根据可能性去确定要去收集左右子树的哪些信息,写出信息体
    // (3)根据收集来左右子树的信息得到自己的这些信息
    // (4)返回信息体类型对象
}
