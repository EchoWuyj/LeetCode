package alg_03_leetcode_top_zcy.class_01_Done;

/**
 * @Author Wuyj
 * @DateTime 2023-02-13 12:22
 * @Version 1.0
 */

// 无重复字符的最长子串
public class problem_003_lengthOfLongestSubstring {

    // 特别经典的题目
    public int lengthOfLongestSubstring(String s) {

        // 子串:必须连续的部分才是为字串
        // 子序列:可以由不连续部分拼接成

        // 经典解法:
        // 字串假设以i位置结尾的情况下答案(无重复字符的最长子串)是什么?并且求所有可能的结尾,最后再去求max

        // dp[]:记录每个位置i往左推到的索引位置,但是本题没必要使用整个dp数组
        // 因为查询i位置,只要查询i-1位置的答案;i+1位置,只要查询i位置的答案,故使用int pre滚动更新即可
        // 使用有限几个变量,就可以记录上一步答案是什么

        // i位置(假设该位置为a字符)往左推多远?由这个两个因素决定:
        //  1)上次a出现的位置 -> 可以HashMap实现,但是本题使用数组,效率更高
        //  2)i-1位置结尾往左推了多远? ->
        //     a   ...       a
        //     9            17  => 17位置最远推到10位置
        //     a   ...       a
        //       11[12   16     => 16位置最远推到12位置(一旦越过12位置,则i-1中存在重复字符)
        // => 这两个因素谁距离a比较近,则为往左推不到的位置

        // 过滤无效参数
        if (s == null || s.equals("")) {
            // KeyPoint 长度不可能为-1,最小为0
            return 0;
        }

        char[] chars = s.toCharArray();

        // 这里使用数组来实现HashMap的效果,速度更快
        // 字符都是在0-255之间(范围更大),通过数组来记录字符的位置
        // 若是只是大小英文字符,则可以使用128长度数组
        int[] map = new int[256];
        for (int i = 0; i < 256; i++) {
            // 每个字符都没有出现,标记为-1
            map[i] = -1;
        }

        // 收集答案,比较是否能变得更大
        int len = 0;

        // i-1位置结尾的情况下,往左推,推不动的位置(数组索引)是谁?
        // 11  [12,13...16]17  11是推不动的位置
        // pre
        // 又因为最开始是0位置,所以pre为-1
        int pre = -1;
        // 中间过程无重复字符子串的长度
        int cur = 0;

        // KeyPoint 复杂度分析:核心代码 for 循环,遍历一遍
        //  时间复杂度:O(N) 空间复杂度:O(1)

        for (int i = 0; i < s.length(); i++) {
            // per是i位置结尾的情况下,往左推,推不动的位置(pre是不断更新的)
            // 该值是由:i-1位置推不动和该字符上次出现位置,距离i位置比较近的决定

            // Math.max因为索引值越大,则距离i位置更近
            // max中的pre是i-1位置的往左推,推不动的位置

            // pre(i-1信息) => pre(i信息)
            pre = Math.max(pre, map[chars[i]]);
            // 当前位置(i)-推不动位置(pre)=长度
            // 11 | 12,13...16,17
            // pre             i
            // 因为17是不想包括的,所以可以利用求长度的方式,直接使用17-12=5得到长度,即12~16
            cur = i - pre;
            len = Math.max(len, cur);
            // 更新字符索引位置,我这个字符出现我这个位置
            // i是chars字符数组中位置
            map[chars[i]] = i;
        }
        return len;


    }
}
