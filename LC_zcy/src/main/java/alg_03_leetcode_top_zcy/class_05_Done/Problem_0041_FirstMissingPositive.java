package alg_03_leetcode_top_zcy.class_05_Done;

/**
 * @Author Wuyj
 * @DateTime 2023-02-18 18:56
 * @Version 1.0
 */

// 缺失的第一个正数
public class Problem_0041_FirstMissingPositive {

    /*
        KeyPoint 遇到做过的题,假装没有做过,假装现场想出来的,需要演技

        给你一个未排序的整数数组nums,请你找出其中没有出现的最小的正整数
        请你实现时间复杂度为O(n),并且只使用常数级别额外空间的解决方案

        长度为10的数组
             [       ]
              0     9 10
              L       R
         1) L位置代表[0,L-1]范围上,该范围上每个位置都做到i位置放的是i+1,i是0-L-1上的每个位置
            一开始L在0位置,则[0,-1]是无效范围,表示一个数都没有做到i位置放的是i+1
            随着遍历的过程中,L是需要不断往右扩的,若L=5,则表示[0-4],满足i位置放的是i+1
            KeyPoint 注意:每个位置都得做到,才能右扩,否则不能让L右扩
            [1,2,3,4,5] 元素
             0 1 2 3 4  索引

         2) R含义:代表没有看过的部分,假设是最优的预期,尽可能大的整数
            [0,9]都没有看过,最优的预期是1-10数字全都有,因此尽可能大的整数为10;

            a) 情况一:预期是[1-R],当前数字([L])>R,则不需该数字
                [-7       ?]
                 0        9 10
                 L          R
               -7不需要,明确知道需要1-10数字,-7和R位置前一个数(?)交换,R往左移动一个位置
               最好预期在变差,变成了[1-9]
               KeyPoint 本质将不想要的数交换到数组的最后位置(R的前一个位置)

            b) 情况二:[L]==L+1,需要的数字,L++
                [1 2 3 ...      ?]
                 0 1 2 ...      9 10
                       L          R
                0位置上做到放1,L右移,做到了i位置放的是i+1,同时1,2位置也是满足要求的

            b) 情况三:当前数([L])<=L,则不需要该数字
                 [1 2 3 1      -7]
                  0 1 2        9 10
                        L      R
                L=3位置上的1<=L=3,则该位置上的1不需要,最好预期在变差,变成了[1-8]
                将1和R前面一个元素交换,R往左移动一个位置

            KeyPoint  L<[L]<=R的两种小情况
            c) 情况四:当前L位置V,L<V<=R,应该放到V-1位置上,而V-1位置上的已经是V了,
                此时L位置上的数是不需要的,V和R位置前一个数(?)交换,V进入垃圾区,最好预期在变差,变成了[1-9]
                [1 2 3 5 5    ?]
                 0 1 2 3 4    9 10
                       L        R

            d) 情况五:当前L位置V,应该放到V-1位置上,而V-1位置上的是W(不是V)了,则只是将将V和W交换
               最好预期没有在变差,[1-R]不发生变化,再从L位置开始判断
                 V=9     W!=9
                 L=3      8


             具体案例:
             5 4 2 1 X
             0 1 2 3 4
             L       R  最优预期1-4,R=4
             5>R,5进入垃圾区,和1交换,R左移一个位置,最优预期[1-3],R=3

             1 4 2 5 X
             0 1 2 3 4
               L   R    最优预期1-3,R=3
             0位置放1,L++
             1位置放4,4>R,4进入垃圾区,和2交换,R左移一个位置,最优预期[1-2],R=2


             1 2 4 5 X
             0 1 2 3 4
                 R    最优预期1-2,R=2
                 L
             1位置放2,L++,L和R位置相碰,流程停止,res=L+1=3;

          KeyPoint 总结:这种方法厉害的点在于,所有的数都没有覆盖的情况下(只是换了顺序),将其找到

     */
    public int firstMissingPositive(int[] nums) {
        int l = 0;
        // r在越界位置
        int r = nums.length;

        // L所在位置始终是第一个不满足i位置,对应数组为i+1的位置
        // 而一旦R和L相遇,则说明此时R前面位置已经没有垃圾区了,此时该位置就是最小正整数索引位置
        // 最终将l+1返回即可
        while (l < r) {
            // 常规情况判断
            if (nums[l] == l + 1) {
                l++;
            } else if (nums[l] <= l || nums[l] > r || nums[nums[l] - 1] == nums[l]) {
                // nums[nums[l]-1] == nums[l]
                // 3位置,数值8 => nums[l]=8 => 该数应该放到7位置,找7位置,即nums[l]-1,7位置的值,即nums[nums[l]-1]
                // 7位置,数值8 => L=3位置的数值8也是不需要的,交换,r-1;
                swap(nums, l, --r);
            } else {
                // V=9     W不为9
                // L=3      8
                // 交换函数,传入的是索引坐标,不是具体的数值
                // 1)L是当前位置的位置索引,该位置的数值为nums[8]
                // 2)应该交换到nums[8]-1的位置,则nums[8]-1就是目标位置索引
                swap(nums, l, nums[l] - 1);
            }
        }

        // 1 2 3 4 5  数组
        // 0 1 2 3 4  索引
        //         L  => 缺的最小正整数为6(L+1)
        return l + 1;
    }

    public void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
