package alg_02_train_dm._29_day_动态规划四;

/**
 * @Author Wuyj
 * @DateTime 2023-06-12 16:35
 * @Version 1.0
 */
public class _05_10_regular_expression_matching {
       /*

        10. 正则表达式匹配
        给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
            '.' 匹配任意单个字符
            '*' 匹配零个或多个前面的那一个元素
             => * 确定下来后，就是固定的一个元素，不能再发生变化了
             => 保证每次出现字符 * 时，前面都匹配到有效的字符
        所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。

        示例 1：
        输入：s = "aa" p = "a"
        输出：false
        解释："a" 无法匹配 "aa" 整个字符串。

        示例 2:
        输入：s = "aa" p = "a*"
        输出：true
        解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'
        因此，字符串 "aa" 可被视为 'a' 重复了一次。

        示例 3：
        输入：s = "ab" p = ".*"
        输出：true
        解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

        示例 4：
        输入：s = "aab" p = "c*a*b"
        输出：true
        解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。
        因此可以匹配字符串 "aab"。

        示例 5：
        输入：s = "mississippi" p = "mis*is*p*."
        输出：false

        提示：
        0 <= s.length <= 20
        0 <= p.length <= 30
        s 可能为空，且只包含从 a-z 的小写字母。
        p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
        保证每次出现字符 * 时，前面都匹配到有效的字符

     */

    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        // 1.状态定义
        // dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配
        // 状态定义是考虑空字符串的，故数组长度加 1
        boolean[][] dp = new boolean[m + 1][n + 1];

        // 2.状态初始化
        // dp[O][O] 表示 s 前 0个字符转换成 p前 0个字符是否配
        // => 空字符串和空字符串是匹配的
        dp[0][0] = true;

        // s：a c d c b
        //    i
        // p：a * c . b
        //        j      => true

        // s：a c d c b
        //    i
        // p：a * c . b
        //              j  => false

        // 状态初始化第一行
        // s 是模式串，对应 dp 数组中每一列，其中存在 '.' 和 '*'，故需要逻辑判断
        for (int i = 1; i <= n; i++) {
            // 前前一个元素匹配空字符串，并且当前字符是 * ，那么是匹配
            // dp[0][i-2]：主要为了处理："a*b*" 这种形式，此外，加上 i < 2，为了避免索引越界
            // 注意：这里不可以不用判断 i < 2
            // 原因是：保证每次出现字符 * 时，前面都匹配到有效的字符符
            if (p.charAt(i - 1) == '*' && (i < 2 || dp[0][i - 2])) {
                dp[0][i] = true;
            }
        }

        // 状态初始化第一列
        // p 是目标串，对应 dp 数组中每一行，其中没有 '.' 和 '*'，都是字母字符
        // 必然不能和'' 匹配，故都是为 false，和 dp 默认的值相同，故不需要额外设置

        // KeyPoint 状态转移方程，一共有 5 种情况

        // s：a c d c b
        //      i
        // p：a c * . b
        //      j
        // 1.若 s[i-1] == p[j-1]，则 dp[i][j] = dp[i-1][j-1]

        // s：a c d c b
        //      i
        // p：a c * . b
        //        j
        // 2.若 s[i-1] != p[j-1]，且 p[j-1] 不是通配符
        // => 则 dp[i][j] == false，可以不用设置，默认是 false

        // s：a c d c b
        //      i
        // p：a c * . b
        //          j
        // 3.若 s[i-1] != p[j-1]，且 p[j-1] = '*'，且 s[i-1] != p[j-2]，即 a != c
        // 则必然需要通过 '*' 消除 p[j-2] (c) 才能匹配上，将 'c *' 变成 0 个 c，故 dp[i][j] = dp[i][j-2]
        // KeyPoint '*' 能变成一个或者多个前面字符，若 '*' 位置索引为 j-1，则必然需要分析 j-2 位置字符，判断其是否相等

        // s：a c d c b
        //        i
        // p：a c * . b
        //          j
        // 4.若 s[i-1] != p[j-1]，且 p[j-1] = '*'，且 s[i-1] == p[j-2] (或者 p[j-2] =='.' => s[i-1] == p[j-2])
        // KeyPoint 此时有 2 种情况，一定是分析极端情况 => '*' 要么没有，要么最长
        //          其他中间情况则是在 2 个极端情况当中，不用一一枚举中间情况
        // 1) 若通过 '*' 将 p 中 c 消除，'c *' 变成 0 个 c，使用 s 中 c 和 p 中 a 匹配，则 dp[i][j] = dp[i][j-2]
        // 2) 若通过 '*' 将 s 中 c 消除，'*' 变成多余一个 c，和 s 中 c 匹配了
        //    剩余则用 s 中 a 和 p 中 * 匹配，则 dp[i][j] = dp[i-1][j]
        //    注意：'*' 多余一个 c 后还是 '*'，同时，分析过程中，假设匹配上的字符，就不用再考虑 dp 状态，对剩下的字符进行考虑 dp
        //  => dp[i][j] = dp[i-1][j] || dp[i][j-2]

        // s：a c d c b
        //      i
        // p：a c * . b
        //            j
        // 5.若 s[i-1] != p[j-1]，且 p[j-1] = '.'，则 dp[i][j] = dp[i-1][j-1]

        // 从第 2 行，第 2 列，开始状态转移
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 情况 1 和 情况 5
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p.charAt(j - 1) == '*') {
                    //  情况 4 的 2 种子情况
                    // '*' 只能匹配 '*' 前面的字符，需要往前看一个字符 j-2
                    if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') {
                        dp[i][j] = dp[i - 1][j] || dp[i][j - 2];
                    } else {
                        // 情况 3
                        dp[i][j] = dp[i][j - 2];
                    }
                }
            }
        }

        return dp[m][n];
    }
}
