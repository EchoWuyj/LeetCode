package alg_02_train_dm._02_day_一维数组;

/**
 * @Author Wuyj
 * @DateTime 2023-04-17 12:36
 * @Version 1.0
 */
public class _02_189_rotate_array1 {

    /*
        189. 轮转数组
        给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

        进阶
        1 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
        2 你可以使用空间复杂度为O（1）的原地算法解决这个问题吗？

        输入: nums = [1,2,3,4,5,6,7], k = 3
        输出: [5,6,7,1,2,3,4]
        => 将后面 3 个元素 [5,6,7]，从后移动到数组前面 [1,2,3,4]
        => [5,6,7,1,2,3,4]
        解释:
        向右轮转 1 步: [7,1,2,3,4,5,6] => 每个元素依次向右移动 1 位
        向右轮转 2 步: [6,7,1,2,3,4,5] => 每个元素依次向右移动 2 位
        向右轮转 3 步: [5,6,7,1,2,3,4] => 每个元素依次向右移动 3 位


        输入：nums = [-1,-100,3,99], k = 2
        输出：[3,99,-1,-100]
        解释:
        向右轮转 1 步: [99,-1,-100,3]
        向右轮转 2 步: [3,99,-1,-100]

        提示
        1 <= nums.length <= 10^5
        -2^31 <= nums[i] <= 2^31 - 1

        KeyPoint 数据规模 与 时间复杂度
        0 <= k <= 10^5 => O(k*n) 10^5 * 10^5 = 10^10 × 必定超时

     */

    // KeyPoint 方法一：使用额外数组
    public void rotate1(int[] nums, int k) {
        int n = nums.length;
        // KeyPoint 注意事项
        // 1.避免 k > n，避免后续 nums[k] 出现越界
        // 2.k % n ，将 k 多走的 m 轮，通过取余的方式消除
        k = k % n;

        // 临时存储旋转之后的数组
        int[] tmpArr = new int[n];
        for (int i = 0; i < n; i++) {
            // i+k 相当于，将原来 i 位置移动到 i+k 位置
            // 若遇到抽象数学公式，不是很理解，则通过体例子来验证
            // => i+k，通过 i = 0，k = 3 验证其正确性
            // 取余数组长度，避免越界
            int index = (i + k) % n;
            tmpArr[index] = nums[i];
        }
        // tmpArr copy 到原数组 nums 中 => System.arraycopy
        System.arraycopy(tmpArr, 0, nums, 0, n);
    }




}
