package alg_02_train_dm._02_day_一维数组_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-04-17 21:06
 * @Version 1.0
 */
public class _06_31_next_permutation_推荐 {

    /*
        31. 下一个排列
        整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。
        例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。

        KeyPoint 补充
        数组元素 1,2,3 全排列
         [1,2,3]
         [1,3,2]
         [2,1,3]
         [2,3,1]
         [3,1,2]
         [3,2,1]

        整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。
        更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，
        那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。
        如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即其元素按升序排列）。

        例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
        类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
        而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
        给你一个整数数组 nums ，找出 nums 的下一个排列。

        必须 原地 修改，只允许使用额外常数空间。

        示例 1：
        输入：nums = [1,2,3]
        输出：[1,3,2]

        示例 2：
        输入：nums = [3,2,1]
        输出：[1,2,3]

        示例 3：
        输入：nums = [1,1,5]
        输出：[1,5,1]

        提示：
        1 <= nums.length <= 100
        0 <= nums[i] <= 100


        KeyPoint 分析过程 => 本质：找规律

        下一个排列 => 保证字典序更大
        ======
        123456 => 将 5 定义成尽量靠右的[较小数] => 降序第一个元素 5 6
                                                                ↑
               => 将 6 定义成尽量靠右且比[较小数]大的[较大数] => 从右往左第一个比[较小数]大  5 6
                                                                                        ↑
               => 将[较小数]和[较大数]交换即可得到下一个排列，
               => 交换 '5' 和 '6'，123465

        ======
        123465 => 较小数 => 降序第一个元素 4 6 5
                                          ↑
               => 较大数 => 从右往左第一个比[较小数]大 4 6 5
                                                       ↑
               => 交换 '4'和 '5'，123564
               => 再去反转 '64'，123546

        ======
        123546 => 交换 '4'和 '6'，123564

        ======
        123564 => 交换 '5'和 '6'，123654
               => 再去反转 '54'，123645

        ======
        123645 => 交换 '4' 和 '5'，123654

        ======
        123654 => 交换 '3' 和 '4'，124653，再去反转 '653'，124356

        ...

     */

    // KeyPoint
    // 1.给定一个数组正常思维，从左往右遍历来解决问题
    // 2.在一定的场景下，尝试从右往左遍历，可能有助于解决某些问题
    public void nextPermutation(int[] nums) {

        int n = nums.length;
        // 1. 从数组尾部开始遍历，尽量找到靠右的[较小数]
        int i = n - 2;
        // 从数组倒数第 2 个元素开始找，往前遍历
        // 1.i >= 0，能取等，保证索引不越界
        // 2.i 从 n-2 开始，保证 nums[i+1] 不越界

        // KeyPoint 区别：while 执行和结束条件
        // while 结束条件：nums[i] < nums[i + 1]
        // => while 执行条件：nums[i] >= nums[i + 1]
        // => 找降序第一个元素
        // KeyPoint 记住：找第一个 xxx，最后一个 xxx，while 循环实现
        while (i >= 0 && nums[i] >= nums[i + 1]) i--;

        // 2. 如果找到了[较小数]
        if (i >= 0) {
            // 找到尽量靠右的[较大数]
            int j = n - 1;
            // KeyPoint 区别：while 执行和结束条件
            // while 结束条件：num[j] > num[i]
            // => while 执行条件为 '严格相反情况' => num[j] <= num[i]
            // 总结：
            // 1.通过 '反向思维' 推导 while 循环条件
            // 2.while() => 循环成立条件
            // => 从右往左第一个比[较小数]大
            while (j >= 0 && nums[i] >= nums[j]) j--;

            // 交换[较小数]和[较大数]
            swap(nums, i, j);
        }

        // 3. 反转[较小数] i 之后的所有元素
        // 没有较小数，此时数组是最大排列，直接反转即可
        reverse(nums, i + 1);
    }

    // 反转
    private void reverse(int[] nums, int start) {
        int left = start, right = nums.length - 1;
        while (left < right) {
            swap(nums, left, right);
            left++;
            right--;
        }
    }

    // 交换
    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    /*

     KeyPoint 另外一种实现 => 推荐使用
     public void nextPermutation(int[] nums) {
        int n = nums.length;
        int i = n - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) i--;
        if (i >= 0) {
            int j = n - 1;
            while (j >= 0 && nums[i] >= nums[j]) j--;
            swap(nums, i, j);
            reverse(nums, i + 1, n - 1);
        }
        if (i == -1) {
            reverse(nums, 0, n - 1);
        }
    }

     */
}
