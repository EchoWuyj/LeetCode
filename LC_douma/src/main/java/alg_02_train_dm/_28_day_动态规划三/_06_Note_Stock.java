package alg_02_train_dm._28_day_动态规划三;

/**
 * @Author Wuyj
 * @DateTime 2023-06-10 20:05
 * @Version 1.0
 */
public class _06_Note_Stock {
    /*

        买卖股票的最佳时机
        给定一个数组 prices，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
        prices 7 1 5 3 6 4

        ----------------------------------------

        121. 买卖股票的最佳时机
        你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票 => 一次交易
        设计一个算法来计算你所能获取的最大利润。
        prices  7  1  5  3  6  4
        索引    0  1  2  3  4  5
                   ↑        ↑
                 买入      卖出
        最大利润：6 - 1 = 5

        ----------------------------------------

        122. 买卖股票的最佳时机 II
        设计一个算法来计算你所能获取的最大利润。你可以 尽可能地完成更多的交易(多次买卖一支股票)
        注意：你不能同时参与多笔交易(你必须在再次购买前出售掉之前的股票)
        prices  7  1   5    3    6  4
        索引    0  1   2    3    4  5
                   ↑   ↑    ↑    ↑
                 买入 卖出 买入 卖出 => 受制于 prices 数组，才交易了 2 次，否则能交易更多次
        第一交易：5 - 1 = 4
        第二交易：6 - 3 = 3
        最大利润：4+3=7

        ----------------------------------------

        123. 买卖股票的最佳时机 III
        设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
        注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
        prices  3  3   5   0   0  3   1    4
        索引    0  1   2   3   4  5   6    7
                           ↑      ↑   ↑    ↑
                         买入   卖出  买入 卖出
        第一交易：3 - 0 = 3
        第二交易：4 - 1 = 3
        最大利润：3+3=6

        ----------------------------------------

        188. 买卖股票的最佳时机 IV
        设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。
        注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
        prices  2    4   1
        索引    0    1   2
                ↑    ↑
               买入 卖出     k=2
        第一交易：4-2=2
        最大利润：2

        ----------------------------------------

        309. 最佳买卖股票时机含冷冻期
        设计一个算法计算出最大利润。
        在满足以下约束条件下，你可以 尽可能地完成更多的交易(多次买卖一支股票):
        1. 你不能同时参与多笔交易(你必须在再次购买前出售掉之前的股票)。
        2. 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
        prices  1    2   3  0   2
        索引    0    1   2  3   4
                ↑    ↑      ↑   ↑
               买入 卖出   买入 卖出
        第一交易：2-1=1
        第二交易：2-1=1
        最大利润：1+2=3

        ----------------------------------------

        714. 买卖股票的最佳时机含手续费
        你可以 无限次 地完成交易，但是你每笔交易都需要付手续费。
        如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
        返回获得利润的最大值。
        注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费
        prices  1  3  2  8   4   9
        索引    0  1  2  3   4    5   手续费 fee=2
                ↑        ↑   ↑   ↑
               买入     卖出 买入 卖出
        第一交易：(8-1)-2=5
        第二交易：(9-4)-2=3
        最大利润：5+3=8;

        ----------------------------------------

        买卖股票问题总结：
        prices  1    2   3  0   2
        索引    0    1   2  3   4

        121 => 只交易一次
        122 => 可以交易无限次数
        123 => 最多交易 2 次
        188 => 最多交易 k 次
        309 => 可以交易无限次数 + 冷冻期
        714 => 可以交易无限次数 + 手续费

        最优值问题 + 通过枚举方式求解 + 且存在重复值 => 动态规划

        n：表示股票价格数组的长度
        i: 表示第 i 天 (i 的取值范围 0... n-1)
        k: 表示允许的最大交易次数

        给定一个表示每天股票价格的数组，什么因素决定了可以获得的最大利润?
        1.在哪天进行交易
        2.允许交易的次数
        => 状态参数

        初步状态定义：
        状态定义：dp[i][k]：表示在第 i 天结束时，最多进行了 k 次交易的情况下，可以获得的最大利润

        第 i 天的操作：买入，卖出，休息
        限制条件: 你不能同时参与多笔交易(你必须在再次购买前出售掉之前的股票)
        第 i 天卖出的话，那么第 i 天之前必须持有股票
        第 i 天买入的话，那么第 i 天之前必须不持有股票
        => 股票是否持有 => 影响获得的最大利润
        => 因此，状态参数还需要加上 "是否持有股票"

        最终状态定义：
        dp[i][k][0]：表示在第 i 天结束时，最多进行了 k 次交易后，不持有股票情况下，可以获得的最大利润
        dp[i][k][1]：表示在第 i 天结束时，最多进行了 k 次交易后，持有股票情况下，可以获得的最大利润

        状态初始化
        dp[i][0][0]：表示在第 i 天结束时，没有进行任何交易，也不持有股票，所以利润为 0

        分析 i,k 都是一般意义上状态，具有通用性

        dp[i][k][0]：表示在第 i 天结束时，经过 k次交易，且不持有股票：那么
            1.前一天不持股，然后今天休息，最大利润为：dp[i-1][k][0]
            2.前一天持股，然后今天卖出，最大利润：dp[i-1][k][1] + prices[i]
            => 注意：i 一般是和相邻 1 天 (i-1) 进行比较，而不是相邻的多天 (i-n)比较
            => 其中 i-1 天再由 i-2 天推导
            dp[i][k][0] = max{dp[i-1][k][0],dp[i-1][k][1] + prices[i]}

        dp[i][k][1]：表示在第 i 天结束时，经过 k次交易，且持有股票：那么
            1.前一天持股，然后今天休息，最大利润为：dp[i-1][k][1]
            2.前一天不持股，然后今天买入，最大利润：dp[i-1][k-1][0] - prices[i]
             => 在买卖股票中，定义买入操作算作一次交易，而卖出不算一次交易
             => 注意：k-1 的原因：买入操作会使用一次交易
            dp[i][k][1] =  max{ dp[i-1][k][1],dp[i-1][k-1][0] - prices[i]}




     */
}
