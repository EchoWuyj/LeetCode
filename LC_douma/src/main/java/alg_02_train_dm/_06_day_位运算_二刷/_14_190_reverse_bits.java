package alg_02_train_dm._06_day_位运算_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-04-23 16:44
 * @Version 1.0
 */
public class _14_190_reverse_bits {

    /*
        190. 颠倒二进制位
        颠倒给定的 32 位无符号整数的二进制位。

        提示：
        请注意，在某些语言（如 Java）中，没有无符号整数类型。
        在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，
        因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
        在 Java 中，编译器使用二进制'补码'记法来表示有符号整数。
        因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

        示例 1：
        输入：n = 00000010100101000001111010011100
        输出：964176192 (00111001011110000010100101000000)
        解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
             因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

        KeyPoint 思路分析
        技巧：将二进制位 4 位一组，比较容易看，不易混淆
         n  0000 0010 1001 0100 0001 1110 1001 1100
        颠倒：从右侧最低位 0 开始，依次将每位作为高位，从新排列
             => 将低位变高位，高位变低位
        输入 0000 0010 1001 0100 0001 1110 1001 1100
        输出 0011 1001 0111 1000 0010 1001 0100 0000 => 964176192

        示例 2：
        输入：n = 11111111111111111111111111111101
        输出：3221225471 (10111111111111111111111111111111)
        解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
             因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。

        提示：
        输入是一个长度为 32 的二进制字符串
        进阶: 如果多次调用这个函数，你将如何优化你的算法？
     */

    // KeyPoint 方法一 直接模拟法
    // 时间复杂度 O(k) k 为常数
    // 输入是一个长度为 32 的二进制字符串
    public int reverseBits1(int n) {

        // n   0000 0010 1001 0100 0001 1110 1001 110|1 => 右移 1 位，将 1 加入到 res 最低位
        // res 0000 0000 0000 0000 0000 0000 0000 0000

        // n  0|000 0001 0100 1010 0000 1111 0100 111|0 => 右移 1 位，将 0 加入到 res 最低位
        // res 0000 0000 0000 0000 0000 0000 0000 0001| => 注意：低位 1，只是暂时的低位，在 res 不断左移过程中，低位会变高位
        //                                              => res 左移一位，加入 0

        // n  00|00 0000 1010 0101 0000 0111 1010 0111
        // res 0000 0000 0000 0000 0000 0000 0000 0010

        int res = 0;
        // 0 ~ 31 位，即：从 低位 到 高位
        for (int i = 0; i < 32; i++) {
            // res << 1 => 将 res 左移一位(先操作)
            // n & 1 => 获取 n 的最后一位，并将该位置为 1
            res = (res << 1) | (n & 1);
            // 力扣提示：you need treat n as an unsigned value
            // 注意：将 n 是无符号整数，故这里可以使用 有符号 右移
            // 最好使用 无符号右移 >>>=，避免不必要错误
            n >>= 1;
        }
        return res;
    }

    // KeyPoint 方法二 分治法
    // 注意：位运算，需要加上括号，要不然有问题
    // 时间复杂度O(1) => 性能非常好，只是进行有限次位运算
    public int reverseBits2(int n) {

        // KeyPoint 分治思想：将大问题拆分成小问题，小问题解决了，大问题就解决了

        // 分析过程：从顶向下
        // 0100 1010 1001 0100 | 0001 1110 1001 1101
        // => 前一半和后一半颠倒 => 每 32 位的前后交换

        // 0001 1110 1001 1101 | 0100 1010 1001 0100
        // => 每 16 位进行交换

        // 1001 1101 | 0001 1110 | 1001 0100 | 0100 1010
        // => 每 8 位进行交换

        // 1101 | 1001 | 1110 | 0001 | 0100 | 1001 | 1010 | 0100
        // => 每 4 位进行交换

        // ...
        // => 每 2位 进行交换
        // ...

        // 实现过程：自低向上
        // 每 2 位 进行交换
        // 每 4 位 进行交换
        // 每 8 位 进行交换
        // 每 16 位 进行交换
        // 每 32 位 进行交换

        // 原始数据
        // 0100 1010 1001 0100 0001 1110 1001 1101

        // 每 2 位 进行交换
        //   0 0  1 1  1 0  0 0  0 0  1 1  1 0  1 0  => 每 2 位，前一位，右移一位
        //    1 0  0 0  0 1  1 0  0 1  1 0  0 1  1 1 => 每 2 位，后一位，左移一位
        //  ---------------------------------------  => 注意：空隙位置都是 0
        //    0 0  1 1  1 0  0 0  0 0  1 1  1 0  1 0
        // | 1 0  0 0  0 1  1 0  0 1  1 0  0 1  1 1  => 或操作
        // ---------------------------------------
        //   1000 0101 0110 1000 0010 1101 0110 1110

        // 交换规则：反向交换
        // 1234  => 每两位进行交换(前一位，后一位交换) => 2143
        // 2143  => 每四位进行交换(前二位，后二位交换) => 4321

        // 原始数据 n
        // 0100 1010 1001 0100 0001 1110 1001 1101

        // 原始数据 n >>> 1
        //   0010 0101 0100 1010 0000 1111 0100 1110
        // & 0101 0101 0101 0101 0101 0101 0101 0101 mask
        //  ----------------------------------------
        //   0000 0101 0100 0000 0000 0101 0100 0100

        // (n >>> 1) & M1 每两位前一半
        // (n & M1) << 1 每两位后一半

        // 注意：mask 整体是 32 位，使用 16 进制表示，其中 4 位表示一个字母
        //      mask 一共 8 个 16 进制字符，16 进制是以 0x ... 开头，不是 Ox 开头

        // 2位交换 (整体是2位)
        int M1 = 0x55555555; // 0101 0101 0101 0101 0101 0101 0101 0101
        // 4位交换
        int M2 = 0x33333333; // 0011 0011 0011 0011 0011 0011 0011 0011
        // 8位交换
        int M4 = 0x0f0f0f0f; // 0000 1111 0000 1111 0000 1111 0000 1111
        // 16位交换
        int M8 = 0x00ff00ff; // 0000 0000 1111 1111 0000 0000 1111 1111

        // 注意：这里使用无符号右移 >>>
        // 且 M1，M2，M3，M4 都要随着变化
        n = ((n >>> 1) & M1) | ((n & M1) << 1); // 每两位进行交换
        n = ((n >>> 2) & M2) | ((n & M2) << 2); // 每四位进行交换
        n = ((n >>> 4) & M4) | ((n & M4) << 4); // 每八位进行交换
        n = ((n >>> 8) & M8) | ((n & M8) << 8); // 每十六位进行交换
        return (n >>> 16) | (n << 16); // 32 位的前后交换
    }
}
