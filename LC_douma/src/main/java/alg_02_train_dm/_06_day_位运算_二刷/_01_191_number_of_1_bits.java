package alg_02_train_dm._06_day_位运算_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-04-21 20:03
 * @Version 1.0
 */
public class _01_191_number_of_1_bits {

    /*
        191. 位 1 的个数 => 汉明重量
        编写一个函数，输入是一个 无符号 整数(以二进制串的形式)
        返回其二进制表达式中数字位数为 '1' 的个数(也被称为：汉明重量)

        提示： 输入必须是长度为 32 的 二进制串

        示例 1：
        输入：n = 00000000000000000000000000001011
        输出：3
        解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

        示例 2：
        输入：n = 00000000000000000000000010000000
        输出：1
        解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'

        示例 3：
        输入：n = 11111111111111111111111111111101
        输出：31
        解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

        请注意，在某些语言(如 Java)中，没有 无符号 整数类型。
        在这种情况下，输入和输出都将被指定为：有符号整数类型，并且不应影响您的实现。
        因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
        在 Java 中，编译器使用二进制补码记法来表示有符号整数。
        故在 示例 3 中，输入表示有符号整数 -3。

     */

    // KeyPoint 方法一 对每一位进行判断，看其是否为 1
    // 判断第 i + 1 位是否是 1 => (n & (1 << i))！= 0

    public static int hammingWeight(int n) {
        int res = 0;
        // KeyPoint 位运算加括号
        // 写位运算操作相关代码，注意()使用，最好多加 ()
        // 尤其在 != 和 = 之前，明确运算的前后顺序，否则代码报错
        // i 的范围 0 ~ 31
        for (int i = 0; i < 32; i++) {

            // KeyPoint 注意事项
            // n & (1 << i) 判断第 i 位是否为 1，但是 (n & (1 << i)) 整体数值 不一定为 1
            // 如：n = 7
            //  ... 8 4 2 1
            //      0 1 1 1
            //  i = 0 => 0 位为 1 => (n & (1 << i)) = 1
            //  i = 1 => 1 位为 1 => (n & (1 << i)) = 2
            //  i = 2 => 2 位为 1 => (n & (1 << i)) = 4
            // 总结：(n & (1 << i)) 结果 0 或者 是一个非零值
            // => if 判断条件： (n & (1 << i)) != 0，而不是 (n & (1 << i)) == 1
            if ((n & (1 << i)) != 0) {
                // KeyPoint 输出打印 => 调试 bug
                // System.out.println((n & (1 << i)));
                // 输出打印，分析代码是否执行，纠正自己错误的思维
                res++;
            }
        }
        return res;
    }

    public static void main(String[] args) {
        // 主方法输入参数 int n (如：001011) 是 10 进制数值，不是二进制串 001011
        // 10进制数字 7 对应 .... 0111
        System.out.println(hammingWeight(7));
    }

    // KeyPoint 方法二 右移 n 位，每移动一位，判断最后一位是否为 1
    public int hammingWeight2(int n) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            // n 的最后一位和 1 相与
            // 因为限制在最后一位，故其值要么 1，要么 0
            res += n & 1;
            // 有符号右移 和 无符号右移都是一样，因为我们只右移 32 位
            // KeyPoint += => 类比 >>=，每次右移 1 位
            n >>= 1;

            // 上面代码，另外一种形式
//            if ((n & 1) == 1) res++;
//            n >>= 1;
        }
        return res;
    }

    // KeyPoint 方法三 每次移除掉最后一个 1，直至 n 为 0
    // 去掉最后一位 1 => n & (n-1)
    // 注意：在二进制串中 1 的个数比较小，该算法性能最好，只要执行 1 个数次位运算即可
    public int hammingWeight3(int n) {
        int res = 0;
        // 直到 n = 0，跳出 while 循环
        while (n != 0) {
            n = n & (n - 1);
            res++;
        }
        return res;
    }
}
