package alg_02_train_dm._06_day_位运算_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-04-21 19:40
 * @Version 1.0
 */
public class _00_Note_位运算_技巧 {
    /*
            位运算技巧

            =====================================================================

            1. 获取二进制的低 16 位 => n & OxFFFF (32位 OxFFFFFFFF)
               KeyPoint 记忆：获取位数 => 与 & 位数

                n         0000 1010 0001 0000 1111 0010 0000 1010
                &         0000 0000 0000 0000 1111 1111 1111 1111 => 16 进制表示 OxFFFF
                --------------------------------------------------
                          0000 0000 0000 0000 1111 0010 0000 1010

                KeyPoint 记忆 & 操作 => & 0 为 0，& 1 为 自己
                                    => 将 & 理解成 *， n * 0 = 0，n * 1 = n
                &  0 => 消去不想要位，res 全为 0 (高位，设为 0)
                   1 => 保留想要位，res 全为自身 (低 16 位，设为 1)

            =====================================================================

            2. 对二进制的高 16 位进行取反 => 先对低 16 位取反，再对整个二进制取反
                                        => ~(n ^ 0xFFFF)
                KeyPoint 记忆：取反位数 => ~( 异或 位数)
                2.1 先对低 16 位取反
                n         0000 1010 0001 0000 1111 0010 0000 1010
                ^ OxFFFF  0000 0000 0000 0000 1111 1111 1111 1111
                -----------------------------------------------
                          0000 1010 0001 0000 0000 1101 1111 0101 => 高 16 位不变，低 16 位取反

                ^ 1，异或操作：不同为 1，相同为 0
                     01 或 01 => 1
                     00 或 11 => 0

                0 ^ 1 => 1
                1 ^ 1 => 0
                => 相当于：将低 16 位的每一位都取反

                2.2 再对整个二进制取反
                       ~  0000 1010 0001 0000 0000 1101 1111 0101
                -------------------------------------------------
                          1111 0101 1110 1111 1111 0010 0000 1010 => 高 16 位取反
                                                                  => 低 16 位再取反，变成会原样
                OxFFFF => mask 掩码

            =====================================================================

            3. 判断第 i + 1 位是否是 1 => (n & (1 << i))！= 0
                     => 2^0 = 1，故 i 从 0 位开始的
                     => 因此，i => 对应 i+1

               KeyPoint 本质：获取 i+1 位 => n & (1 << i)，判断自身是否为 1

                res = (i+1) & 1
                    1.若 res 1，i+1 为 1
                    2.若 res 0，i+1 为 0

               '最后一位'是否是 1 =>  n & 1 != 0
                                 => 1 等价于 左移 0 位

                n     0000 1010 0001 0000 1111 0010 0000 101|0 => 判断 1 位否是 1
                &     0000 0000 0000 0000 0000 0000 0000 000|1 => 1 二进制形式中，1 就在 1 位上，故 i = 0
                -----------------------------------------------
                      0000 0000 0000 0000 0000 0000 0000 0000

            =====================================================================

            4. 去掉最后一位 1 => n & (n-1)
                              => 注意：1 的位置，不一定在末尾，后面可能后面有 0，
                                       但是一定是最后一个 1，后面没有 1 了

               KeyPoint：1.n & n 还是 n，对'位'运算，1 & 1 = 1，0 & 0 = 0
                         2.n 和 n-1 只是最后一个位不同，故 1 & 0 或者 0 & 1 = 0，从而将最后一位去掉
                    记忆：n & (n-1) => n 去掉最后一位 1，变成 n-1

                 n     0000 1010 0001 0000 1111 0010 0000 1010 => 将最后一位 1 去掉
               & n-1   0000 1010 0001 0000 1111 0010 0000 1001
                 -----------------------------------------------
                       0000 1010 0001 0000 1111 0010 0000 1000

            =====================================================================

            5. 获取最后一位 1 => n & (-n) =>
                                或者 n & ~(n-1)
                                或者 n^(n & (n-1))

               KeyPoint 记忆：获取，联想 -> &
                              正负相与，只剩下最后一位
                              => n & (-n) => 最后一位

                n     0000 1010 0001 0000 1111 0010 0000 1010 => 正数：原反补都是一样

               -n     1000 1010 0001 0000 1111 0010 0000 1010 => 负数：运算过程，使用的补码

               原码    1000 1010 0001 0000 1111 0010 0000 1010
               反码    1111 0101 1110 1111 0000 1101 1111 0101 取反(不包括高位)
               加 1                                          1
               -----------------------------------------------------
               补码：  1111 0101 1110 1111 0000 1101 1111 0110

                n     0000 1010 0001 0000 1111 0010 0000 1010
              & -n    1111 0101 1110 1111 0000 1101 1111 0110
              -------------------------------------------------
                      0000 0000 0000 0000 0000 0000 0000 0010 => 获取最后一位 1

            =====================================================================

            6. A 的位减去 B 的位：A &(～B)
               KeyPoint A &(～B) 形式上类似：A - B

                A   0000 1011 1111 0010 0000 0000 1101 0000

                B   0000 0001 0010 1111 1101 0000 1010 1000
                -------------------------------------------
                    0000 1010 1101 0000 0000 0000 0101 0000 => 简单理解 0-1 的结果是 0

               ~B   1111 1110 1101 0000 0010 1111 0101 0111

                A   0000 1011 1111 0010 0000 0000 1101 0000
             & ~B   1111 1110 1101 0000 0010 1111 0101 0111
             --------------------------------------------------
                    0000 1010 1101 0000 0000 0000 0101 0000

            补充：拆分相减
                     11101011
                   - 10000000
                  -------------
                     01101011
                  -  00010000
                  -------------
                     01011011
                  -  00000110
                  -----------
                     1010101

            =====================================================================

            7. ^ 用法技巧
            KeyPoint 异或，位， 相同为 0，不同为 1
                           => 1 ^ 1 = 0， 0 ^ 0 = 0
                           => 1 ^ 0 = 1， 0 ^ 1 = 1
                     记忆：推广
                           变量：a 相同为 0，不同为自身
                           => a ^ a = 0， a ^ 0 = a

                a ^ 0 = a
                a ^ a = 0
                a ^ b ^ c = a ^ c ^ b => 和顺序无关

                a  0101 0001
              ^ 0  0000 0000
               --------------
                   0101 0001

                a  0101 0001
              ^ a  0101 0001
               --------------
                   0000 0000
     */
}