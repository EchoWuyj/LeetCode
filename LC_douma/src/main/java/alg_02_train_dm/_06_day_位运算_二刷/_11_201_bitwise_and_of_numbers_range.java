package alg_02_train_dm._06_day_位运算_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-04-23 12:33
 * @Version 1.0
 */
public class _11_201_bitwise_and_of_numbers_range {

    /*
        201. 数字范围按位与
        给你两个整数 left 和 right ，表示区间 [left, right] ，
        返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。

        示例 1：
        输入：left = 5, right = 7
        输出：4

        示例 2：
        输入：left = 0, right = 0
        输出：0

        提示：
        0 <= left <= right <= 2^31 - 1

     */

    // KeyPoint 方法一 暴力解法
    // 0 <= left <= right <= 2^31 - 1 => 10^10 => 超出时间限制
    // 2^(31)-1 => 2147483647，即 21 亿 => 21 * 10^8
    // 记忆：21 4748 3647 => 21 亿，死去死吧，36 47
    // 1亿，一共有 9 位数，包括最高位的 1 => 100 000 000 => 10^8
    public int rangeBitwiseAnd1(int left, int right) {
        int ans = left;
        for (int i = left + 1; i <= right; i++) {
            ans &= i;
        }
        return ans;
    }

    // KeyPoint 方法二 找规律，位运算，右移和左移
    // O(k) k 最大为 32
    public int rangeBitwiseAnd2(int left, int right) {

        // 优化：通过找规律来优化时间复杂度
        // 比如：数字 9-12 => 连续区间

        // 9  0000 0000 0000 0000 0000 0000 0000 1|001
        // 10 0000 0000 0000 0000 0000 0000 0000 1|010
        // 11 0000 0000 0000 0000 0000 0000 0000 1|011
        // 12 0000 0000 0000 0000 0000 0000 0000 1|100
        // ------------------------------------------
        //    0000 0000 0000 0000 0000 0000 0000 1000
        // 因为 9 到 12 是连续的，除公共前缀部分之外，
        // 后面位的 0 和 1 都是交错出现的，相与的结果必然为 0

        // 通过 left 和 right 找到公共前缀
        //  9  0000 0000 0000 0000 0000 0000 0000 1|001 右移 1 位
        // 12  0000 0000 0000 0000 0000 0000 0000 1|100 右移 1 位
        // ------------------------------------------
        // left 和 right 不断右移，直到 left = right，即找到了二进制串的公共前缀
        // 同时，每次记录移动位数 shift

        //
        // 再将其左移 shift，则为最后的 res

        //  9  0000 0000 0000 0000 0000 0000 0000 1001 右移 1 位

        // 记录移动位数
        int shift = 0;
        // 当 left == right 时，找到 left 和 right 的公共前缀
        while (left < right) {
            // left 和 right 都是正数，直接可以 有符号右移动
            // KeyPoint 区别：左移 <<，右移 >>，两者不要搞混淆了
            left >>= 1;
            right >>= 1;
            shift++;
        }
        // 注意：
        // 1.此时 left 经过多次右移，其二进制形式已经不是原来形式
        //   最后二进制形式： 0000 .... 1，即最后一位是 1，其余位都是 0
        // 2.最后 <<，最好使用 left 或 right，而不是 1，若直接使用 1 可能存在其他问题
        return left << shift;
    }

    // KeyPoint 方法三 不断地抹掉 right 的最后一个 1
    public int rangeBitwiseAnd(int left, int right) {

        // KeyPoint 注意
        // 1.抹掉是 right，而不是 left，关键：理解本质
        // 2.while 循环条件，有可能 left = right，有可能 left > right，
        //   而不是一定 left = right

        // 不断地抹掉 right 最后一个 1，一直到 right <= left 为止
        //  9  0000 0000 0000 0000 0000 0000 0000 1001
        // 12  0000 0000 0000 0000 0000 0000 0000 1100

        // 抹掉 right 最后一个 1，left > right，结束循环
        // 12  0000 0000 0000 0000 0000 0000 0000 1000

        // 另外一个例子
        //  9  0000 0000 0000 0000 0000 0000 0000 1001
        // 14  0000 0000 0000 0000 0000 0000 0000 1110

        // 不断抹掉 right 最后一个 1，直到 right <= left，结束循环
        // 12  0000 0000 0000 0000 0000 0000 0000 1100 => 抹掉 1 个 1
        // 12  0000 0000 0000 0000 0000 0000 0000 1000 => 抹掉 2 个 1

        while (left < right) {
            right = right & (right - 1);
        }
        return right;
    }
}
