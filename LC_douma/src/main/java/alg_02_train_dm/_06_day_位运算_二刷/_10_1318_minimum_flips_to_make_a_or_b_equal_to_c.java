package alg_02_train_dm._06_day_位运算_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-04-23 11:13
 * @Version 1.0
 */
public class _10_1318_minimum_flips_to_make_a_or_b_equal_to_c {

    /*
        1318. 或运算的最小翻转次数
        给你三个正整数 a、b 和 c。你可以对 a 和 b 的二进制表示进行位翻转操作
        返回能够使按位或运算 a | b == c 成立的最小翻转次数。

        「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1

        示例 1：
        输入：a = 2, b = 6, c = 5
        输出：3
        解释：翻转后 a = 1 , b = 4 , c = 5 使得 a | b == c

          a 0010                             a 0001
        | b 0110    对 a，b 的二进制位反转  | b 0100     => 反转次数 1 + 1 + 1 = 3
        ---------                         ---------
            0110                              0101
          c 0101  => a | b != c             c 0101  => a | b == c

        示例 2：
        输入：a = 4, b = 2, c = 7
        输出：1

        提示：
        1 <= a <= 10^9
        1 <= b <= 10^9
        1 <= c <= 10^9

     */

    // 思路：直接模拟
    // 1.通过给定测试用例数据，找规律
    // 2.在通过代码 if else 实现不同情况，不同处理逻辑
    // 先通过 a 和 b 异或，确定哪一位上存在不同。根据不同的位，再去确定需要进行操作，记录反转次数
    public int minFlips(int a, int b, int c) {

        // 具体案例：
        // a = 2, b = 6, c = 5

        //   a 0010
        // | b 0110
        // ---------
        //     0110

        // => a | b 和 c 不同位数，使用异或，不同为 1，相同为 0

        // a|b 0110
        // ^ c 0101
        // ---------
        //     0011 => 从而确定：第一位和第二位不同
        //          => 若 a|b 不同位是 0 => a,b 对应位，只要其中一个位反转成 1 即可，即需要反转 1 次
        //          => 若 a|b 不同位是 1 => 若 a,b 都为 1，则需要反转 2 次，
        //                                 若 a,b 其中为 1，则需要反转 1 次

        // 总结：只有一种情况下需要反转两次，其他情况都是只要反转一次即可
        //      找到规律之后，将不同的情况进行枚举，从而将所有情况分成几个大类，再通过 if else 判断实现即可

        //   a  0 0 1 1
        // | b  0 1 0 1  => a,b 每一位有 2 种可能，一共有 2位，一共有 4 种情况
        // -------------
        //      0 1 1 1
        //   c  1 0 0 0
        // -------------
        //      1 1 1 2

        int aOrb = a | b;
        // 求不同，联想异或
        int abXORc = aOrb ^ c;
        // abXORc == 0 说明 abXORc == aOrb，不需要反转
        if (abXORc == 0) return 0;

        int res = 0;
        // 根据数据范围 1 <= a <= 10^9，从而确定数据类型 int，遍历 32 位即可
        // 一共 32 位，遍历每一位，依次判断
        // i < 31，因为 a，b，c 都是正数，其最高位都是 0，不用反转
        for (int i = 0; i < 31; i++) {

            // 掩码
            int mask = 1 << i;
            // 判断 abXORc 在第 i 位是否为 1
            // 若 if 判断成立，则 a | b 和 c 的第 i 位不同，那么至少需要翻转 1 次
            // KeyPoint 判断某位 mask 是否为 1 => 判断：整体表达式 (表达式 & mask ) > 0，而不是等于 1
            if ((abXORc & mask) > 0) {

                // 如果 a 和 b 的第 i 位是 1，且 c 的第 i 位是 0，那么需要翻转 2 次
                if ((c & mask) == 0 && ((a & mask) == (b & mask))) {
                    res += 2;
                } else {
                    res++;
                }

                // KeyPoint 区别：'表达式二进位为 1'和'整体表达式 10 进制数值'

                // 判断 a 和 b 的第 i 位是 1，不能写成 ((a & mask) == 1) && ((b & mask) == 1)
                // (a & mask) == 1 表示'整体表达式 10 进制数值' = 1，而不是某 i 位上为 1
                // 同时，i 在不断移位的过程中，表达式对应 10 进制也是在不断变化的，不会横固定为 1

                //   a    1 1 0 1
                // & mask 0 1 0 0 => i 位，其中 i = 3
                // ---------------
                //        0 1 0 0
                // a & mask 二进制对应第 3 位为 1，但是 a & mask 却表示 4

                // 注意：因为有前置条件约束，(c & mask) == 0，则 c 的 mask 为 0
                //       且 a，b 与 c 对应位不同，故 a，b 对应位为 1
                //       且 (a & mask) 和 (b & mask) 相等
                //    => a，b mask 位都为 1

                // 注意： 若 c 的 i(mask) 位为 0，则可以推到 (c & mask) == 0
                //   c    1 0 0 1
                // & mask 0 1 0 0  => i 位，其中 i = 3
                // ---------------
                //        0 0 0 0
                // a & mask 二进制对应第 3 位为 0，同时 (c & mask) == 0

            }
        }
        return res;
    }
}
