package alg_02_train_dm._06_day_位运算_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-04-23 13:18
 * @Version 1.0
 */
public class _12_476_number_complement {

    /*
        476. 数字的补数
        对整数的二进制表示取反 (0 变 1，1 变 0)后，再转换为十进制表示，可以得到这个整数的补数。
        例如，整数 5 的二进制表示是 "101" ，取反后得到 "010" ，再转回十进制表示得到补数 2 。
        给你一个整数 num ，输出它的补数。

        示例 1：
        输入：num = 5
        输出：2
        解释：5 的二进制表示为 101(没有前导零位)，其补数为 010。所以你需要输出 2

        提示：1 <= num < 2^31
     */
    public int findComplement(int num) {

        // num = 5 0000 0000 0000 0000 0000 0000 0000 0|101 => 不能包括前导0
        // 目标 0000 0000 0000 0000 0000 0000 0000 0|010

        // KeyPoint 理论依据
        // 对二进制的高 16 位进行取反
        // => 先对低 16 位取反，再对整个二进制取反 => ~(n ^ 0xFFFF)
        // 推广：低 3 位取反，类似：对低 16 位取反
        // => 对 低 3 位中的 1 和 1 进行异或，MASK = 0000 ... 111

        // 如何获取 mask
        // num = 5 0000 0000 0000 0000 0000 0000 0000 0|101
        //         1111 1111 1111 1111 1111 1111 1111 1|111 => 不断左移，直到第一个前导零位，得到 mask
        //                                                     即：num & mask = 0 停止左移
        //  mask   1111 1111 1111 1111 1111 1111 1111 1000
        //  ~mask  0000 0000 0000 0000 0000 0000 0000 0111 => 想要的 MASK

        // num = 5 0000 0000 0000 0000 0000 0000 0000 0101
        // ~mask ^ 0000 0000 0000 0000 0000 0000 0000 0111
        // -------------------------------------------------
        //         0000 0000 0000 0000 0000 0000 0000 0010

        // 注意：32 个 1，2种表示
        // 1.~0 => ~ 取反包括最高位符号位的
        // 2.16 进制的 0xFFFFFFFF (一个 16 进制位代表 4个进制位，32 / 4 = 8 个 16 进制位)

        int mask = ~0;
        while ((num & mask) > 0) mask <<= 1;
        return ~mask ^ num;
    }
}
