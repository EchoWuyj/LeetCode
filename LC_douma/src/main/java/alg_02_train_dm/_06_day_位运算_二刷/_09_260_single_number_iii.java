package alg_02_train_dm._06_day_位运算_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-04-22 21:18
 * @Version 1.0
 */
public class _09_260_single_number_iii {

    /*
        260. 只出现一次的数字 III
        给你一个整数数组 nums，其中 恰好有两个元素只出现一次，其余所有元素均出现两次。
        找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
        你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

        示例 1：
        输入：nums = [1,2,1,3,2,5]
        输出：[3,5]
        解释：[5, 3] 也是有效的答案。

        示例 2：
        输入：nums = [-1,0]
        输出：[-1,0]

        提示：
        2 <= nums.length <= 3 * 10^4
        -2^31 <= nums[i] <= 2^31 - 1
        除两个只出现一次的整数外，nums 中的其他数字都出现两次

     */

    public int[] singleNumber(int[] nums) {

        // [1,2,1,3,2,5]
        // => 关键：用上'异或'运算技巧
        // => 将两个只出现一次元素，分到两个不同的组中 [1,1,3] 和 [2,2,5]
        // => 分别对两个数组所有数字异或 => [3,5]

        // 关键：如何分组?
        // [1,2,1,3,2,5] 把所有的元素进行异或操作，最终得到一个异或值 3 ^ 5
        //   3 0 0 1 1
        // ^ 5 0 1 0 1
        //  -----------
        //     0 1 1 0 => 异或结果 1 对应 二进制位 i，数字 3 和 5 是不一样的二进制
        //                通过将 3 和 5 和 0010 相与，从而能将元素区分成两组

        // 获取异或值 0110 最后一个 1，即 0010
        // 根据 0010 对原始数组中每个元素进行分组

        // 1: 0001 & 0010 = 0000
        // 5: 0101 & 0010 = 0000  [1,1,5]
        // 2: 0010 & 0010 = 0010
        // 3: 0011 & 0010 = 0010  [2,2,3]
        // => 在两个组中，分别有 1 个只出现一次的元素，其余元素都出现两次

        // BitMask
        int bitmask = 0;

        // 把所有的元素进行异或操作，最终得到一个异或值
        // 因为是不同的两个数字，所以这个值必定不为 0；
        for (int num : nums) bitmask ^= num;

        // 取异或值的最后一个二进制位为 1 的数字作为 diff，获取最后一位 1 => n & (-n)
        // 1 则表示两个数字在这一位上不同
        int diff = bitmask & (-bitmask);

        // 通过与这个 diff 进行与操作，如果为 0 的分为一个数组，为 1 的分为另一个数组
        // 这样就把问题降低成了："有一个数组每个数字都出现两次，有一个数字只出现了一次，求出该数字"

        int[] ans = new int[2];
        for (int num : nums) {
            // 根据：相与结果是否为 0 进行分组
            // 因为和 0010 相与，只有 1 那位可能为 1，故根据：相与结果是否为 0 和 1将其区分
            if ((num & diff) != 0) {
                ans[0] ^= num;
            } else {
                ans[1] ^= num;
            }
        }

        return ans;
    }
}
