package alg_02_train_dm._08_day_二分查找;

/**
 * @Author Wuyj
 * @DateTime 2023-04-04 19:50
 * @Version 1.0
 */

//
public class _13_69_sqrtX {

    /*
        69. x 的平方根
        给你一个 非负 整数 x ，计算并返回 x 的算术平方根 。
        由于返回类型是整数，结果只保留 整数部分，小数部分将被 舍去 。
        注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

        示例 1：
        输入：x = 4
        输出：2
        
        示例 2：
        输入：x = 8
        输出：2
        解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
    
        提示：
        0 <= x <= 2^31 - 1

     */

    // KeyPoint 方法一 时间复杂度：O(x)
    // 0 <= x <= 2^(31) - 1 => 2147483647，即 21 亿 => 21 * 10^8 => 超时
    // 1亿，一共有 9 位数，包括最高位的 1 => 100 000 000 => 10^8
    public int mySqrt1(int x) {
        int res = -1;

        // x = k^2，√x = k，因为 k 可能存在小数，将小数抹去
        // => x >= k^2，找最大 k，使得 k^2 <= x 即可，
        // => k 的取值：[0,x] 依次进行判断，直到找到最大的 k

        for (int k = 0; k <= x; k++) {

            // 当 x 值非常大时，for 循环中 k*k 乘积结果可能数据溢出，导致结果为负值
            // 如：2147395599 * 2147395599，乘积结果会数据溢出，导致结果为负值：-837308191
            // 从而导致 k*k <= x 是成立的，即导致每次 res 都记录 k 的值，直到 res = x = 2147395599

            // 解决：强转 long，避免数据溢出
            // 即使 2147395599 * 2147395599 = 4611307858604568801
            // long 也能接受，但是，不满足 if 条件，即：k * k <= x，故 res 也不会是 2147395599
            // 注意：虽然数据不溢出，但是超时
            if ((long) k * k <= x) {
                // 每次循环，记录 k
                res = k;
            }
        }
        return res;

        // 输入：
        // 2147395599
        // 输出：
        // 2147395599
        // 预期结果：
        // 46339

        // 分析
        // 输入：2147395599
        // 对比：2147483647 (int 最大值)，输入值没有超出 int 数据范围

    }

    // KeyPoint 方法二 二分查找
    // 方法一是从 0 到 x 进行线性查找，且数列是严格升序的数组 => 二分查找
    // 时间复杂度：O(logx)
    public int mySqrt(int x) {
        // 遍历范围 [0,x] 的两端，就对应的 left 和 right
        int left = 0, right = x;
        int ans = -1;
        // 不断在循环体内找到 k
        while (left <= right) {
            int k = left + (right - left) / 2;
            if ((long) k * k <= x) {
                // 需要将 k 记录下来，因为求解的是 k 的最大值
                ans = k;
                // k 不一定是最大值，让 left 右移，看看 k 是否还能再增大
                left = k + 1;
            } else {
                right = k - 1;
            }
        }
        return ans;
    }
}
