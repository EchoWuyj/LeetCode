package alg_02_train_dm._06_day_位运算;

/**
 * @Author Wuyj
 * @DateTime 2023-04-22 21:18
 * @Version 1.0
 */
public class _09_260_single_number_iii {

    /*

        260. 只出现一次的数字 III
        给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。
        找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
        你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

        示例 1：
        输入：nums = [1,2,1,3,2,5]
        输出：[3,5]
        解释：[5, 3] 也是有效的答案。

        示例 2：
        输入：nums = [-1,0]
        输出：[-1,0]

        提示：
        2 <= nums.length <= 3 * 10^4
        -2^31 <= nums[i] <= 2^31 - 1
        除两个只出现一次的整数外，nums 中的其他数字都出现两次

     */

    public int[] singleNumber(int[] nums) {
        // [1,2,1,3,2,5] => 将两个只出现一次元素，分到两个不同的组中
        // [1,1,3] 和 [2,2,5] => 分别对两个数组所有数字异或 => [3,5]

        // [1,2,1,3,2,5] 把所有的元素进行异或操作，最终得到一个异或值 3 ^ 5
        //   3 0011
        // ^ 5 0101
        //  --------
        //     0110 => 1 对应二进制位 3 和 5 不一样 1 和 0，从而能将元素区分成两组

        // 拿到 0110 取最后一个位 1，即 0010
        // 根据 0010 对原始数组中每个元素进行分组

        // 取最后一个位 1原因，

        // 1 0001 & 0010 = 0000
        // 5 0101 & 0010 = 0000  [1,1,5]
        // 2 0010 & 0010 = 0010
        // 3 0011 & 0010 = 0010  [2,2,3]

        // 把所有的元素进行异或操作，最终得到一个异或值，因为是不同的两个数字，所以这个值必定不为 0；
        int bitmask = 0;
        for (int num : nums) bitmask ^= num;

        // 取异或值最后一个二进制位为 1 的数字作为 diff，如果是 1 则表示两个数字在这一位上不同。
        // 获取最后一位 1 => n & (-n)
        int diff = bitmask & (-bitmask);

        // 通过与这个 diff 进行与操作，如果为 0 的分为一个数组，为 1 的分为另一个数组
        // 这样就把问题降低成了："有一个数组每个数字都出现两次，有一个数字只出现了一次，求出该数字"
        int[] ans = new int[2];
        for (int num : nums) {
            // 根据：相与结果是否为 0 进行分组
            if ((num & diff) != 0) {
                ans[0] ^= num;
            } else {
                ans[1] ^= num;
            }
        }

        return ans;
    }
}
