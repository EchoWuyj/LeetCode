package alg_02_train_dm._06_day_位运算;

/**
 * @Author Wuyj
 * @DateTime 2023-04-23 16:44
 * @Version 1.0
 */
public class _14_190_reverse_bits {

    /*
        190. 颠倒二进制位
        倒给定的 32 位无符号整数的二进制位。

        提示：
        请注意，在某些语言（如 Java）中，没有无符号整数类型。
        在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，
        因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
        在 Java 中，编译器使用二进制'补码'记法来表示有符号整数。
        因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

        示例 1：
        输入：n = 00000010100101000001111010011100
        输出：964176192 (00111001011110000010100101000000)
        解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
             因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

        分析：4位一组，比较好颠倒
        n =  0000 0010 1001 0100 0001 1110 1001 1100
        颠倒 0011 1001 0111 1000 0010 1001 0100 0000 => 将低位变高位，高位变低位
             0011 1001 0111 1000 0010 1001 0100 0000 => 964176192

        示例 2：
        输入：n = 11111111111111111111111111111101
        输出：3221225471 (10111111111111111111111111111111)
        解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
             因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。

        提示：
        输入是一个长度为 32 的二进制字符串

        进阶: 如果多次调用这个函数，你将如何优化你的算法？
     */

    // KeyPoint 方法一 直接模拟法
    public int reverseBits1(int n) {

        // n   0000 0010 1001 0100 0001 1110 1001 1101 => 右移 1 位，将 1 加入到 res 最低位
        // res 0000 0000 0000 0000 0000 0000 0000 0000

        // n   0000 0001 0100 1010 0000 1111 0100 1110 => 右移 1 位，将 0 加入到 res 最低位
        // res 0000 0000 0000 0000 0000 0000 0000 0001 => res 左移一位，加入 0

        // n   0000 0000 1010 0101 0000 0111 1010 0111
        // res 0000 0000 0000 0000 0000 0000 0000 0010

        int res = 0;
        for (int i = 0; i < 32; i++) {
            // res << 1 => 将 res 左移一位(先操作)
            // n & 1 => 获取 n 的最后一位，并将该位置为 1
            res = (res << 1) | (n & 1);
            // n 是无符号整数，故这里可以使用有符号右移
            n >>= 1;
        }
        return res;
    }

    private static final int M1 = 0x55555555; // 01010101010101010101010101010101
    private static final int M2 = 0x33333333; // 00110011001100110011001100110011
    private static final int M4 = 0x0f0f0f0f; // 00001111000011110000111100001111
    private static final int M8 = 0x00ff00ff; // 00000000111111110000000011111111

    // KeyPoint 方法二 分治法 => 将大问题拆分成小问题，小问题解决了，大问题就解决了
    // 位运算，需要加上括号，要不然有问题
    // 时间复杂度O(1) => 性能非常好，只是进行有限次位运算
    public int reverseBits2(int n) {

        // 分治思想
        // 0100 1010 1001 0100 0001 1110 1001 1101 => 前一半和后一半颠倒 => 每 32 位的前后交换
        // 0001 1110 1001 1101 | 0100 1010 1001 0100 => 每 16 位进行交换
        // 1001 1101 | 0001 1110 | 1001 0100 | 0100 1010 => 每 8 位进行交换
        // 1101 | 1001 | 1110 | 0001 | 0100 | 1001 | 1010 | 0100 => 每 4 位进行交换
        // ...

        // 每两位进行交换过程
        // 0100 1010 1001 0100 0001 1110 1001 1101
        // 0 0  1 1  1 0  0 0  0 0  1 1  1 0  1 0  => 右移一位
        //  1 0  0 0  0 1  1 0  0 1  1 0  0 1  1 1 => 左移一位
        // ---------------------------------------
        //  0 0  1 1  1 0  0 0  0 0  1 1  1 0  1 0
        //|1 0  0 0  0 1  1 0  0 1  1 0  0 1  1 1
        // ---------------------------------------
        // 1000 0101 0110 1000 0010 1101 0110 1110

        // 反向交换
        // 1234  => 每两位进行交换(前一位和后一位交换) => 2143
        // 2143  => 每四位进行交换(前二位和后二位交换) => 4321

        // (n >>> 1) & M1 每两位前一半
        // (n & M1) << 1 每两位后一半
        n = ((n >>> 1) & M1) | ((n & M1) << 1); // 每两位进行交换
        n = ((n >>> 2) & M2) | ((n & M2) << 2); // 每四位进行交换
        n = ((n >>> 4) & M4) | ((n & M4) << 4); // 每八位进行交换
        n = ((n >>> 8) & M8) | ((n & M8) << 8); // 每十六位进行交换
        return (n >>> 16) | (n << 16); // 32 位的前后交换
    }
}
