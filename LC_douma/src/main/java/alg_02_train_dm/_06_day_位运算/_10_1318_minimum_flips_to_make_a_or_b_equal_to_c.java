package alg_02_train_dm._06_day_位运算;

/**
 * @Author Wuyj
 * @DateTime 2023-04-23 11:13
 * @Version 1.0
 */
public class _10_1318_minimum_flips_to_make_a_or_b_equal_to_c {

    /*
        1318. 或运算的最小翻转次数
        给你三个正整数 a、b 和 c。
        你可以对 a 和 b 的二进制表示进行位翻转操作
        返回能够使按位或运算 a | b == c 成立的最小翻转次数。

        「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1

        示例 1：
        输入：a = 2, b = 6, c = 5
        输出：3
        解释：翻转后 a = 1 , b = 4 , c = 5 使得 a | b == c

          a 0010                            a 0001
        | b 0110    对 a，b 的二进制位反转  | b 0100     => 反转次数 1 + 1 + 1 = 3
        ---------                         ---------
            0110                              0101
          c 0101  => a | b != c             c 0101  => a | b == c

        示例 2：
        输入：a = 4, b = 2, c = 7
        输出：1

        提示：
        1 <= a <= 10^9
        1 <= b <= 10^9
        1 <= c <= 10^9

     */

    // 思路：先通过异或，确定哪一位上存在不同，根据不同再去确定反转几次
    public int minFlips(int a, int b, int c) {

        // a = 2, b = 6, c = 5

        //   a 0010
        // | b 0110
        // ---------
        //     0110
        // ^ c 0101
        // ---------
        //     0011

        int aOrb = a | b;
        // 求不同，联想异或
        int equal = aOrb ^ c;
        // equal ==0 说明 equal == aOrb，不需要反转
        if (equal == 0) return 0;

        int ans = 0;
        // 一共 32 位，遍历每一位，依次判断
        //  i < 31，因为 a，b，c 都是正数，其最高位都是 0，不用反转
        for (int i = 0; i < 31; i++) {
            // 掩码
            int mask = 1 << i;
            // 判断 equal 在第 i 位是否为 1，若 if 判断成立，
            // 则 a | b 和 c 的第 i 位不同，那么至少需要翻转 1 次
            if ((equal & mask) > 0) {

                // 将不同的情况进行枚举，从而将所有情况分成几个大类，再通过 if else 判断实现即可
                //   a  0 0 1 1
                // | b  0 1 0 1
                // -------------
                //      0 1 1 1
                //   c  1 0 0 0
                // -------------
                //      1 1 1 2
                // 只有一种情况下需要反转两次，其他情况都是只要反转一次即可

                // KeyPoint 按位判断是否为 1，在不断移位的过程中，对应 10 进制也是在不断变化的
                // if ((c & mask) == 0 && (((a & mask) == 1) && ((b & mask) == 1)))
                // ((a & mask) == 1) && ((b & mask) == 1) 判断条件不对，
                //     2  0010
                // & 1<<2 0010
                // -------------
                //          1 => 对应第 2 位上为 1，但是对应 10 进制值却是 2，不在原来 1 的位置了
                // 故只能判断 (a & mask) 和 (b & mask) 相等

                // 如果 a 和 b 的第 i 位是 1，且 c 的第 i 位是 0，那么需要翻转 2 次
                if ((c & mask) == 0 && ((a & mask) == (b & mask))) {
                    ans += 2;
                } else {
                    ans++;
                }
            }
        }
        return ans;
    }
}
