package alg_02_train_dm._21_day_综合应用二_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-05-26 20:37
 * @Version 1.0
 */
public class _11_440_k_th_smallest_in_lexicographical_order2 {



    // KeyPoint 方法二 前缀树
    // 总体流程
    // 1.先判断数字 k 属于哪个子树，然后在当前子树往下一层级移动
    // 2.然后重复找子树和往下层移动的过程，直到找到节点（也就是数字）
    public int findKthNumber(int n, int k) {

        // KeyPoint 逻辑分析
        // 以 1 为前缀，字典序：1 < 10 < 11 < 12 ... 19
        // 10 往后更加细粒度划分：10 < 100 < 101 < 102 ...
        // 注意：数字 0 对应 ASCII 48，"" 空 对应 ASCII 32
        // 将其抽象成每层都是 10 叉树
        // 同理：以 2，3，...，9 为前缀的 10 叉树 => 一共有 9 颗 10 叉数

        // KeyPoint 树形结构图 => 以 1 为前缀

        //            1
        //     ↙   ↓   ↓    ↘
        //    10   11  12 .. 19
        //  ↙ ↓  ↘
        // 100 101 .. 109

        // 求解第 K 小数字，对这 9 颗 10 叉数，进行先序遍历，找到第 K 小数字即可

        // KeyPoint 存在问题
        // 若直接前序遍历，则是按照 "根左右" 顺序遍历树
        // 因为数据规模太大，从而导致性能很慢，故需要确定 k 属于那颗子树

        // KeyPoint 优化
        // 先判断数字 k 属于哪个子树
        // n：209，k：40

        //           cur                       next
        //            ↓                          ↓
        //            1                          2
        //     ↙   ↓   ↓    ↘           ↙   ↓   ↓    ↘
        //    10   11  12 .. 19          20   21  22 .. 29
        //  ↙ ↓  ↘                  ↙ ↓  ↘
        // 100 101 .. 109          200 201 .. 209

        // next - cur = 1 该层有 1 个数字
        // 1 < 40

        // 移动 next 和 cur 指针
        // 同时需要  check 两指针 cur 和 next 是否超过 209

        //                  1                            2
        //           ↙   ↓   ↓    ↘              ↙   ↓   ↓    ↘
        //    cur → 10   11  12 .. 19   next →  20   21  22 .. 29
        //        ↙ ↓  ↘                     ↙ ↓  ↘
        //       100 101 .. 109             200 201 .. 209

        // next - cur = 10 该层有 10 个数字
        // 11 < 40

        // 移动 next 和 cur 指针
        // 同时需要  check 两指针 cur 和 next 是否超过 209

        //                  1                            2
        //           ↙   ↓   ↓    ↘              ↙   ↓   ↓    ↘
        //          10   11  12 .. 19           20   21  22 .. 29
        //        ↙ ↓  ↘                     ↙ ↓  ↘
        // cur → 100 101 .. 109      next → 200 201 .. 209

        // next - cur = 100 该层有 100个数字
        // 111 > 40 => 第 40 小数字在 以 1 为前缀的树中

        // ============================================================

        // cur 从以 1 为前缀树开始
        int cur = 1;
        k = k - 1;
        // 1.若 k=0，跳过 while 循环，直接返回 cur
        // 2.若 k>0，则没有找到 k 小，执行 while 循环
        while (k > 0) {
            // 1.若 cur = 1 (以 1 为前缀树)，则 next = cur+1 = 2 (以 2 为前缀树)
            // 2.若 cur = 10 (以 10 为前缀树)，则 next = cur+1 = 11 (以 11 为前缀树)
            int nodes = count(n, cur, cur + 1);

            // 根据 nodes 和 k 大小关系，判断 k 是在当前的前缀树中，还是在下一颗前缀树中
            if (nodes <= k) {
                // 1.不在当前的前缀中 => 到下个前缀树上找
                // 减掉该前缀树上的节点数
                k -= nodes;
                // cur 移动到下颗前缀树上
                cur += 1;
            } else {
                // 2.nodes > k，在当前的前缀树中，移动到下层位置上找
                // 减去上层一个元素，在下层找 k-1 小的数字
                k -= 1;
                // cur 移动到下层
                cur *= 10;
            }
        }
        return cur;
    }

    // 函数功能：计算当前 cur 前缀树中小于 n 的节点数
    // cur => 当前前缀树
    // next => 下个前缀树
    // 注意：cur 和 next 可能会越界，所以使用 long 类型存储
    public int count(int n, long cur, long next) {
        // 记录节点个数
        int nodes = 0;
        // 若 cur > n，则存在大于 n 的节点数，故结束循环
        // 返回记录节点个数 nodes
        while (cur <= n) {

            // KeyPoint 解释：为什么是 n+1？

            //      1
            //   ↙ ↓ ↘
            //  10 11  12 ..

            // 若 n 为 12，计算 nodes
            // 首先 1 本身是一个节点
            // 下面 10，11，12，三个节点
            // 故一共有 4 个子节点。

            // 计算 10，11，12，两端都是需要包括的
            // 12 - 10 + 1 = 3
            // 故 next 取 min(n+1, next)

            // 注意：next 可能超过 n，此时使用 next - cur
            // 导致小于 n 的节点数算多了，故得使用 Math.min 取较小值
            nodes += (Math.min(n + 1, next) - cur);

            // cur 和 next 计算一轮之后，两指针移到下一层
            // cur 和 next 可能会越界，所以使用 long 类型存储
            cur *= 10;
            next *= 10;
        }
        return nodes;
    }
}
