package alg_02_train_dm._25_day_贪心算法二_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-04-13 14:56
 * @Version 1.0
 */
public class _10_330_patching_array {

         /*
            330. 按要求补齐数组
            给定一个已排序的正整数数组 nums，和一个正整数 n
            从 [1, n] 区间内选取任意个数字补充到 nums 中，
            使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。
            请输出满足上述要求的 最少需要补充的数字个数
            KeyPoint 注意：在 nums 数组中，同一个数字 num 不能重复使用
        
            示例 1:
            输入: nums = [1, 3], n = 6
            输出: 1
            解释:
            根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
            现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
            其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
            所以我们最少需要添加一个数字。

            示例 2:
            输入: nums = [1,5,10], n = 20
            输出: 2
            解释: 我们需要添加 [2, 4]。
            [1,2,4,5,10] 可以表达出 [1, 20] 数字
        
            示例 3:
            输入: nums = [1,2,2], n = 5
            输出: 0

            提示：
            1 <= nums.length <= 1000
            1 <= nums[i] <= 104
            nums 按 升序排列
            1 <= n <= 231 - 1

         */

    public int minPatches(int[] nums, int n) {

        // KeyPoint 分析

        // [1,20]
        // 从 1 开始，每次累加 1，逐个数字分析
        // 若数字无法被表示，则加入新元素，同时加入的数字尽量覆盖更大的范围
        // => 贪心思想：每次加入 nums 数都要在满足条件的前提下尽可能的大以覆盖更大的范围

        // [1] => 无法表达 2
        // [1,1] 表达 1,2
        // [1,2] 表达 1,2,3 => 表示范围更更大，选择这种方式

        // [1,2] => 无法表达 4
        // [1,2,4] 表达 1,2,3,4,5,6,7
        // ...
        // [1,2,4,8,16] 能表达 [1,20]
        //       i-1 i
        // 规律：数组加入的数字中，'后一个数字'是'前一个数字'的 2 倍

        // 结论:对于正整数 x，如果区间 [1，x-1] 内的所有数字都已经被覆盖
        //      且 x 在数组中，则区间[1，2x-1]内的所有数字也都被覆盖
        // 覆盖范围：[1，x-1 + x] => [1，2x-1]

        // 如：x = 4
        // [1,x-1] => [1,3] 已经被覆盖
        // [1，2x-1] => [1,7] 已经被覆盖

        int res = 0;
        // 1.x 表示不断扩张的覆盖范围
        //   贪心的保证 [1, x-1] 这个区间中所有数字会被覆盖
        // 2.在下面代码中，涉及 x*=2，且 数据范围：1 <= n <= 2^31 - 1
        //   => 故 x 有可能会溢出，所以使用 long 接受
        long x = 1;
        // 遍历数组中每个元素
        int index = 0;
        int len = nums.length;
        // x > n 则表示，[1,n] 区间所有数字可以被表示，则跳出循环
        // 否执，x <= n 执行循环操作
        while (x <= n) {
            // 遍历数组中每个元素 nums[index] 和 x 进行比较大小
            if (index < len && nums[index] <= x) {
                // nums[index] <= x，则说明 nums[index] 可以 x 被覆盖
                // 将 nums[index] 累加到 x 中，扩大的 x 覆盖范围
                x += nums[index];
                index++;

                // 数学证明：
                // x 覆盖范围 [1,2x-1] => [1,x+x-1]，且 nums[index] <= x
                // nums[index] + x-1 <= x + x-1 => 即 nums[index] + x-1 能被覆盖到，更新 x += nums[index]

            } else {
                // 1.nums[index] > x，说明 x 不在数组中，需要把 x 放入数组中 => res++
                // 2.没有加入 x 之前，[1,x-1] 已经被覆盖，加入 x，则 [1,2x-1] 也被被覆盖
                //   而 2x 没有被覆盖，故 x 下次从 2x 开始判断 => x *= 2
                res++;
                x *= 2;
            }
        }
        return res;
    }
}
