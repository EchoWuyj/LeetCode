package alg_02_train_dm._25_day_贪心算法二_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-04-13 14:54
 * @Version 1.0
 */
public class _08_861_score_after_flipping_matrix {
     /*
        861. 翻转矩阵后的得分
        有一个二维矩阵 A 其中每个元素的值为 0 或 1。
        移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。
        在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。
        返回尽可能高的分数。
    
        示例：
        输入：[[0,0,1,1],
              [1,0,1,0],
              [1,1,0,0]]

        贪心：想要得到一个数最大，使其最高位越大越好
        1.每行第一位置，二进制高位，保证尽可能为 1
            8 4 2 1   8 4 2 1
            1 0 0 0 > 0 1 1 1

        2.除了每行第一位置，二进制高位为 1，其他位置 1 越多越好

          [[0,0,1,1], => 移动该行 => 保证每行开头数字都是 1
           [1,0,1,0],
           [1,1,0,0]]

          [[1,1,0,0],
           [1,0,1,0],
           [1,1,0,0]]
                ↑ ↑
              移动该两列，'少一多零'调整 => 有利可图
                         '多一少零'不调整 => 无利可图

          [[1,1,1,1],  --> 15
           [1,0,0,1],  --> 9
           [1,1,1,1]]  --> 15

        输出：39

        提示：
        1 <= A.length <= 20
        1 <= A[0].length <= 20
        A[i][j] 是 0 或 1
     */

    public int matrixScore(int[][] grid) {
        int rows = grid.length, cols = grid[0].length;
        // 1.遍历每一行，使得每一行都从 1 开头
        for (int i = 0; i < rows; i++) {
            // 若该行开头元素为 0 => 行翻转
            if (grid[i][0] == 0) {
                // 行翻转 => 确定一行 i，从左往右，挨个进行反转
                for (int j = 0; j < cols; j++) {
                    // ^ 异或，和 ^1， 0 -> 1，1 -> 0
                    // 注意：这里需要真的调整，因为会影响后面代码中，计算矩阵每一列 1 的个数 => 涉及赋值 ^=
                    grid[i][j] ^= 1;

                    // 三元表达式写法
                    // grid[i][j] = (grid[i][j] == 0) ? 1 : 0;
                }
            }
        }

        // 记录翻转矩阵后的得分
        int res = 0;

        // 2.遍历每一列，1 数量越多，得到的数值越大
        for (int j = 0; j < cols; j++) {
            // 记录该列 1 个数
            int count = 0;
            // 统计第 j 列有多少个 1
            // 确定 j，从上往下统计 1 的个数
            for (int i = 0; i < rows; i++) {
                // 直接累加即可，[i][j] = 0 不影响结果
                count += grid[i][j];
            }

            // 1 和 0 的个数，谁多，就将其当做 1 的个数
            // => 等价于将'少一多零'进行调整，而'多一少零'不不调整

            int maxCount = Math.max(count, rows - count);
            // KeyPoint 这里可以不需要真的去翻转矩阵，直接计算最后结果即可
            // KeyPoint 位运算记得加括号，提高运算优先级
            res += maxCount * (1 << (cols - j - 1));

            // 通过列的方式来计算矩阵的得分，每个 1 所在位置表示的值是独立，不会相互影响
            // [[1,1,1,1], =>
            //  [1,0,0,1],
            //  [1,1,1,1]]
            //   ↑
            //  1 所在位置，对应二进制值：2^3 => 1 << 3，其中 3 = cols - j - 1 = 4 - 0 - 1 = 3
            //  同时该列有 maxCount(3) 个
            //  => res += 2^3 * 3

            // KeyPoint 调试 bug
            // 发现 bug，先大概扫一眼，是否能轻易找到 bug
            // 若没有找到 bug，则对代码中几个关键步骤之间，进行打印输出，分析该阶段输出是否有错误
            // 提高解决 bug 效率，很好的方式
            // => 总体原则：不断缩小 bug 范围，直到找到 bug

        }
        return res;
    }
}
