package alg_02_train_dm._29_day_动态规划四_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-06-12 16:35
 * @Version 1.0
 */
public class _05_10_regular_expression_matching_推荐 {
       /*

        10. 正则表达式匹配
        给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
            '.' 匹配任意单个字符
            '*' 匹配零个或多个前面的那一个元素
             => * 确定下来后，就是固定的一个元素，不能再发生变化了
             => 保证每次出现字符 * 时，前面都匹配到有效的字符
        所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。

        示例 1：
        输入：s = "aa" p = "a"
        输出：false
        解释："a" 无法匹配 "aa" 整个字符串。

        示例 2:
        输入：s = "aa" p = "a*"
        输出：true
        解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'
        因此，字符串 "aa" 可被视为 'a' 重复了一次。

        示例 3：
        输入：s = "ab" p = ".*"
        输出：true
        解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

        示例 4：
        输入：s = "aab" p = "c*a*b"
        输出：true
        解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。
        因此可以匹配字符串 "aab"。

        示例 5：
        输入：s = "mississippi" p = "mis*is*p*."
        输出：false

        提示：
        0 <= s.length <= 20
        0 <= p.length <= 30
        s 可能为空，且只包含从 a-z 的小写字母。
        p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
        保证每次出现字符 * 时，前面都匹配到有效的字符

     */

    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        // 1.状态定义
        // dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配
        // 状态定义是考虑空字符串的，故数组长度加 1
        boolean[][] dp = new boolean[m + 1][n + 1];

        // 2.状态初始化
        // dp[0][0] 表示 s 前 0个字符转换成 p前 0个字符是否配
        // 注意：数字 0 中间是有左斜杆的，和大写字母 O 相区别
        // => 空字符串和空字符串是匹配的
        dp[0][0] = true;

        // s：a c d c b
        //    i
        // p：a * c . b
        //        j      => true

        // s：a c d c b
        //    i
        // p：a * c . b
        //              j  => false

        // 状态初始化第一行
        // s 是模式串，对应 dp 数组中每一列，其中存在 '.' 和 '*'，故需要逻辑判断
        for (int j = 1; j <= n; j++) {

            // KeyPoint 注意实现
            // 1.dp 中 j 索引 对应 字符串 p 中 j-1 索引，有差 1 的位置关系
            // 2.dp[0][j-2] 主要为了处理："a*b*" 这种形式，后面的 * 能使得前面字符 a b 变成 0 个，从而保证匹配
            //   => 前前一个元素 j-2 匹配空字符串，并且当前字符 j 是 * ，那么是匹配
            // 3.代码表达式中涉及索引坐标变换 j-2，注意索引不要越界，严格加上 j >= 2，注意逻辑条件 &&
            if (p.charAt(j - 1) == '*' && (j >= 2 && dp[0][j - 2])) {
                dp[0][j] = true;
            }
        }

        // 原因是：保证每次出现字符 * 时，前面都匹配到有效的字符符

        // 状态初始化第一列
        // p 是目标串，对应 dp 数组中每一行，其中没有 '.' 和 '*'，都是字母字符
        // 必然不能和'' 匹配，故都是为 false，和 dp 默认的值相同，故不需要额外设置

        // KeyPoint 状态转移方程，一共有 5 种情况

        // s：a c d c b
        //      i
        // p：a c * . b
        //      j
        // 1.若 s[i-1] == p[j-1]，则 dp[i][j] = dp[i-1][j-1]

        // s：a c d c b
        //      i
        // p：a c * . b
        //        j
        // 2.若 s[i-1] != p[j-1]，且 p[j-1] 不是通配符
        // => 则 dp[i][j] == false，默认是 false，可以不用设置

        // KeyPoint 分析思路
        // '*' 能变成一个或者多个前面字符，若 '*' 位置索引为 j-1，则必然需要分析 j-2 位置字符
        // 从而判断 p 的 j-2 位置字符和 s 的 i-1 位置字符否相等，再根据是否相等，将其分成两种情况

        // s：a c d c b
        //      i
        // p：a c * . b
        //          j
        // 3.若 s[i-1] != p[j-1]，且 p[j-1] = '*'，且 s[i-1] != p[j-2]，即 a != c
        // 则必然需要通过 '*' 消除 p[j-2] (c) 才能匹配上，将 'c *' 变成 0 个 c，故 dp[i][j] = dp[i][j-2]

        // s：a c d c b
        //        i
        // p：a c * . b
        //          j
        // 4.若 s[i-1] != p[j-1]，且 p[j-1] = '*'，且 s[i-1] == p[j-2] (或者 p[j-2] =='.' => s[i-1] == p[j-2])
        // KeyPoint 此时有 2 种极端情况， 一定是分析极端情况
        // 当 '*' 和前面字符 'c' 绑定后
        // 1.c * 要么没有，即 0 个 c
        // 2.c * 要么最长，消除 s 中的 c 后，依然是 c *
        // 其他中间情况，则是在 2 个极端情况当中，不用一一枚举中间情况

        // 详细分析过程：
        // 1) 若通过 '*' 将 p 中 c 消除，'c *' 变成 0 个 c，使用 s 中 c 和 p 中 a 匹配
        //    => 则 dp[i][j] = dp[i][j-2]
        // 2) 若通过 '*' 将 s 中 c 消除，'*' 变成多余一个 c，和 s 中 c 匹配了
        //    => 剩余部分字符，用 s 中 a 和 p 中 * 匹配 ('*' 多余一个 c 后还是 '*') 则 dp[i][j] = dp[i-1][j]
        // 3) 注意，分析过程中，假设匹配上的字符，就不用再考虑 dp 状态，对剩下的字符进行考虑 dp
        // 总结： dp[i][j] = dp[i-1][j] || dp[i][j-2]

        // s：a c d c b
        //      i
        // p：a c * . b
        //            j
        // 5.若 s[i-1] != p[j-1]，且 p[j-1] = '.'，则 dp[i][j] = dp[i-1][j-1]

        // 从第 2 行，第 2 列，开始状态转移
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 情况 1 和 情况 5
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p.charAt(j - 1) == '*') {
                    //  情况 4 的 2 种子情况
                    // '*' 只能匹配 '*' 前面的字符，需要往前看一个字符 j-2
                    if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') {
                        dp[i][j] = dp[i - 1][j] || dp[i][j - 2];
                        // 情况 3
                    } else if (s.charAt(i - 1) != p.charAt(j - 2)) {
                        dp[i][j] = dp[i][j - 2];
                    }

                    // KeyPoint 注意：if 判断语句，条件范围选择依据
                    // 尽量将相等的条件放在 if 判断前面，因为条件越苛刻，则限制的范围很小，避免对其他情况也造成影响
                    // => 编写 if 条件判断语句时，将具体、明确的条件，放在前面可以更有效地处理特殊情况，
                    //    从而减少对其他情况的干扰，这样可以提高代码的可读性和性能

                    // s[i-1] != p[j-2] 不等的情况，这个条件的范围很大
                    // 这范围中已经包含了 p[j-2] =='.' 从而影响了正常的判断逻辑
//                    if (s.charAt(i - 1) != p.charAt(j - 2)) {
//                        dp[i][j] = dp[i][j - 2];
//                    } else if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') {
//                        dp[i][j] = dp[i - 1][j] || dp[i][j - 2];
//                    }

                }
            }
        }

        return dp[m][n];
    }
}
