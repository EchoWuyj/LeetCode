package alg_02_train_dm._29_day_动态规划四_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-06-22 17:01
 * @Version 1.0
 */
public class _04_32_longest_valid_parentheses2 {

    // KeyPoint 方法二 动态规划
    // 时间复杂度：O(n)
    // 空间复杂度：O(n)
    public int longestValidParentheses2(String s) {

        // ) ( ) ( ( ( (
        //         j ↑ ↑
        //           i i
        // i 每次移动，都需要遍历前面元素，存在重复计算，导致时间复杂度很高
        // 将 j 索引之前的最长有效括号长度记住，后面遇到重复计算，直接使用即可，从而消除重复计算

        // 枚举方式求解 + 求解最优值 + 存在重复计算 => 动态规划
        // 通过前面计算好的状态，推导出后面状态值，而不是从头开始再遍历一边，从而降低时间复杂度

        // KeyPoint 分情况讨论

        // 情况一 => 情况三特例
        //        ) ( ) ( ( ( (
        //          ↑
        //          i
        // dp     0 0
        // index  0 1
        // => 最开始两个字符不匹配，dp[i] = 0

        // 情况二 => 情况四特例
        //        ) ( ) ( ( ( (
        //            ↑
        //            i
        // dp     0 0 2
        // index  0 1 2
        // => i => ')' 看 i-1 是否是 '('，若匹配，dp[i] = dp[i-2] + 2

        // 情况三
        //        ) ( ) ( ( ( (
        //              ↑
        //              i
        // dp     0 0 2 0
        // index  0 1 2 3
        // => 只要是以 '(' 结尾，则必然不是有效括号，则此时 dp[i] = 0

        // 情况四
        //        ) ( ) ( ( ( ) ) )
        //                    ↑
        //                    i
        // dp     0 0 2 0 0 0 2
        // index  0 1 2 3 4 5 6
        // => i = ')' 且 i-1 '(' 匹配
        // => 单纯看 i 和 i-1 不够，还需要看 i-2 位置 '(' 的 dp[i-2] 的值，若 dp[i-2] 不为 0，则需要加上
        // => dp[i] = dp[i-2] + 2

        // 情况五
        //        ) ( ) ( ( ( ) ) )
        //                ↑     ↑
        //        i -dp[i-1]-1  i
        // dp     0 0 2 0 0 0 2
        // index  0 1 2 3 4 5 6 7
        // => 4.i ')' 且 i-1 ')' 不匹配，分析 i -dp[i-1]-1 位置对应字符是否匹配
        //      an = a₁ + (n - 1) × d => i - x = 2 + dp[n-1] -1 => x = i - dp[n-1] -1
        // => 同时，还得看 dp[i - dp[n-1] -2]，若 dp[i - dp[n-1] -2] 不为 0，则需要加上

        // 总结：本质上就 3 种情况，有两种情况是重复的

        int n = s.length();
        if (n <= 1) return 0;

        // 1. 定义状态
        // dp[i] 表示以下标为 i 的字符结尾，最长有效括号子串的长度
        int[] dp = new int[n];

        // 第一括号，怎么样都没法组成有效括号
        dp[0] = 0;

        // dp 数组默认值是 0，匹配情况单独考虑
        // => 第一个字符和第二个字符相匹配
        if (s.charAt(0) == '(' && s.charAt(1) == ')') dp[1] = 2;
        int res = dp[1];

        // 状态转移，从第 3 个字符开始
        for (int i = 2; i < n; i++) {
            // 只考虑 i => ')'，否则，若 i = '('，必然不是有效括号，则此时 dp[i] = 0
            if (s.charAt(i) == ')') {
                // i-1 => '(' 且 i => ')'
                if (s.charAt(i - 1) == '(') {
                    // 注意：这里是 dp[i-2]，不是 dp[i-1]，i 和 i-1 配对，则 dp[i] 依赖于 dp[i-2]
                    dp[i] = dp[i - 2] + 2;
                } else {
                    // i-1 => ')' 且 i => ')'
                    // 关键：看 i-dp[i-1]-1 位置是否为 '('
                    // 代码中涉及数组下标索引变换，需要保证数组下标索引不越界，如 i-dp[i-1]-1 和 i-dp[i-1]-2
                    // KeyPoint 通过测试用例，将代码分情况讨论的处理逻辑完善
                    // 注意：是 s.charAt(i - dp[i - 1] - 1)，不是 dp[i - dp[i - 1] - 1]
                    if (i - dp[i - 1] >= 1 && s.charAt(i - dp[i - 1] - 1) == '(') {
                        dp[i] = dp[i - 1] + 2 + (i - dp[i - 1] >= 2 ? dp[i - dp[i - 1] - 2] : 0);
                    }
                }
                // 更新 res，可以在 if 两个分支中都去更新，也可以将其提取到外面来
                res = Math.max(res, dp[i]);
            }
        }
        return res;
    }
}
