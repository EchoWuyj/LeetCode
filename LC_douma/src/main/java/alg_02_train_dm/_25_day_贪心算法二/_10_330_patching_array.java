package alg_02_train_dm._25_day_贪心算法二;

/**
 * @Author Wuyj
 * @DateTime 2023-04-13 14:56
 * @Version 1.0
 */
public class _10_330_patching_array {
         /* 330. 按要求补齐数组
            给定一个已排序的正整数数组 nums，和一个正整数 n
            从 [1, n] 区间内选取任意个数字补充到 nums 中，
            使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。
            请输出满足上述要求的最少需要补充的数字个数
        
            示例 1:
            输入: nums = [1, 3], n = 6
            输出: 1
            解释:
            根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
            现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
            其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
            所以我们最少需要添加一个数字。
        
            示例 2:
            输入: nums = [1,5,10], n = 20
            输出: 2
            解释: 我们需要添加 [2, 4]。
            [1,2,4,5,10] 可以表达出 [1, 20] 数字
        
            示例 3:
            输入: nums = [1,2,2], n = 5
            输出: 0

            KeyPoint 分析:
            贪心思想:每次加入nums的数都要在满足条件的前提下尽可能的大以覆盖更大的范围。

            [1,20]
            从 1 开始，每次累加 1，逐个数字分析，若数字无法被表示，则加入新元素，同时加入的数字尽量覆盖更大的范围

            [1,1] 表达 1,2
            [1,2] 表达 1,2,3
            ...
            [1,2,4,8,16] 能表达 [1,20]，数组中 '后一个数字'是'前一个数字'的 2 倍

            结论:对于正整数 x，如果区间 [1，x-1] 内的所有数字都已经被覆盖，
                 且 x 在数组中，则区间[1，2x-1]内的所有数字也都被覆盖
                 KeyPoint => 覆盖范围 [1，x-1 + x] => [1，2x-1]
         */

    public int minPatches(int[] nums, int n) {
        int res = 0;
        // 贪心的保证 [1, x - 1] 这个区间中所有数字会被覆盖
        // bug 修复：在下面 x 需要累加和乘以 2 ，所以有可能会溢出，所以使用 long 接受
        long x = 1;
        // 遍历数组中每个元素
        int index = 0;
        // x > n 则表示，[1,n] 区间所有数字可以被表示，则跳出循环，否则执行循环操作
        // x 表示不断扩张的覆盖范围
        while (x <= n) {
            // 遍历数组中每个元素和 x 进行比较大小
            if (index < nums.length && nums[index] <= x) {
                // 根据贪心思想，[1, x - 1] 区间中所有数字会被覆盖
                // [1, x + x - 1] -> [1, x + nums[index] - 1]
                // 因此 x + 1，x + 2，... x + nums[index] - 1 都会被覆盖到，更新 x += nums[index]
                x += nums[index];
                index++;
            } else {
                // nums[index] > x，说明 x 不在数组中，需要把 x 放入数组中
                // 没有加入 x 之前，[1,x-1] 已经被覆盖，加入 x，则 [1,2x-1] 也被被覆盖
                // 而 2x 没有被覆盖，故 x 下次从 2x 开始判断
                res++;
                x *= 2;
            }
        }
        return res;
    }
}
