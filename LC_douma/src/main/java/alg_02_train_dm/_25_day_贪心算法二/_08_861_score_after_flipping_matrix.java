package alg_02_train_dm._25_day_贪心算法二;

/**
 * @Author Wuyj
 * @DateTime 2023-04-13 14:54
 * @Version 1.0
 */
public class _08_861_score_after_flipping_matrix {
     /*
        861. 翻转矩阵后的得分
        有一个二维矩阵 A 其中每个元素的值为 0 或 1。
        移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。
        在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。
        返回尽可能高的分数。
    
        示例：
        输入：[[0,0,1,1],
              [1,0,1,0],
              [1,1,0,0]]

         贪心:想要得到一个数最大，使其最高位越大越好
           1.每行第一位置，二进制高位，保证尽可能为 1
           2.除了每行第一位置，二进制高位为 1，其他位置 1 越多越好

          [[1,1,0,0], --> 移动该行
           [1,0,1,0],
           [1,1,0,0]]

          [[1,1,1,1],
           [1,0,0,1],
           [1,1,1,1]]
                | |
               移动该列

         [[1,1,1,1],  --> 15
          [1,0,0,1],  --> 9
          [1,1,1,1]]  --> 15

        输出：39

        提示：
        1 <= A.length <= 20
        1 <= A[0].length <= 20
        A[i][j] 是 0 或 1
     */

    public int matrixScore(int[][] grid) {
        int rows = grid.length, cols = grid[0].length;
        // 使得每一行都从 1 开头
        for (int row = 0; row < rows; row++) {
            if (grid[row][0] == 0) {
                // 行翻转 => 确定一行 row，从左往右，挨个进行反转
                for (int col = 0; col < cols; col++) {
                    // 和 ^1， 0 -> 1，1 -> 0
                    // 这里需要真的调整，因为会影响矩阵得分值
                    grid[row][col] ^= 1;
                }
            }
        }
        // 记录翻转矩阵后的得分
        int res = 0;
        // 1 的数量越多，得到的数值越大
        for (int col = 0; col < cols; col++) {
            // 记录该列 1 个数
            int count = 0;
            // 统计第 col 列有多少个 1。
            // 确定 col，从上往下统计 1 的个数
            for (int row = 0; row < rows; row++) {
                // 直接累加即可，[row][col] = 0 不影响结果
                count += grid[row][col];
            }
            // 1 和 0 的个数，谁多取谁
            int maxCount = Math.max(count, rows - count);
            // KeyPoint 不需要真的去翻转矩阵，直接计算最后结果即可
            // 通过列的方式来计算矩阵的得分，每个 1 所在位置表示的值是独立，不会相互影响
            // [[1,1,1,1], --> 2^3，3 = 4 - 0 - 1
            //  [1,0,0,1],
            //  [1,1,1,1]] --> 2^1 = 2
            // KeyPoint 位运算记得加括号，提高运算优先级
            res += maxCount * (1 << (cols - col - 1));
        }
        return res;
    }
}
