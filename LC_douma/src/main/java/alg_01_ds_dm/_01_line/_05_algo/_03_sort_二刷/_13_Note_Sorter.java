package alg_01_ds_dm._01_line._05_algo._03_sort_二刷;

/**
 * @Author Wuyj
 * @DateTime 2023-07-08 21:26
 * @Version 1.0
 */
public class _13_Note_Sorter {
    /*


        1.如何写一个通用的排序算法
        2.排序元素比较 => 对象
        3.分治算法思想

        排序汇总表 => 详细内容见 PPT 排序算法-2

        O(n^2)
        1.插入排序性能最好、其次是选择排序、冒泡排序性能最差
        2.选择排序不是稳定的排序算法
        3.插入排序是最好的选择
        4.对于大规模的乱序数组的排序，可以使用希尔排序(不稳定)

        O(nlogn)
        1.快排时间复杂度最坏情况下是 O(n^2)，合理选择分区点
        2.归并排序在任何情况下的时间复杂度都是 O(nlogn)
        3.归并排序的空间复杂度是 O(n)，快排空间复杂度是 O(logn)
        4.但是快排不是稳定的排序算法，归并是稳定的排序算法

        O(n)
        1.桶排序:桶与桶之间有序、元素均匀的划分到桶中
        2.计数排序:应用在数据范围不大的场景
        3.基数排序:排序数据可以分割出独立的"位"，而且每一位的数据范围不能太大

        O(n^2) 排序算法对比 O(nlogn) 排序算法
        小规模数据，选择使用 O(n^2) 的排序算法
        大规模数据，选择使用 O(nlogn) 的排序算法

        如何写一个通用的排序算法
        1.不能选择线性时间复杂度的桶排序、计数排序、基数排序
        2.小规模数据，可以使用 O(n^2) 的插入排序
        3.大规模数据，可以使用 O(nlogn)的排序算法

        Java 内置的排序算法 Arrays.sort(int[] data)
        1.对于小数据量(小于 47)，使用插入排序
        2.然后小数据量(大于47 而小于 286)，使用递归实现的快速排序
           => 基本数据类型，不用关注稳定性，谁在前谁在后都可以，所以使用快排
        3.对于大数据量使用迭代(自底朝上)实现的归并排序
          空间复杂度 O(n)
          大数据量为什么使用归并排序?
          1.内存不是需要考虑的范围，内存只会越来越便宜
          2.数据量太大，递归实现的快排，导致递归栈太深，导致栈内存溢出


     */
}
